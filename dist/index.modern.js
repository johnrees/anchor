export{default as BN}from"bn.js";import{Connection as t,sendAndConfirmRawTransaction as e,Account as n,PublicKey as r,TransactionInstruction as o,Transaction as s,SystemProgram as a,SYSVAR_RENT_PUBKEY as i}from"@solana/web3.js";import*as c from"@solana/web3.js";export{c as web3};import u from"camelcase";import{snakeCase as l}from"snake-case";import*as d from"js-sha256";import*as f from"@project-serum/borsh";import{inflate as m}from"pako";import p from"eventemitter3";import*as h from"bs58";import*as g from"base64-js";import*as y from"assert";import w from"assert";import{sha256 as v}from"crypto-hash";class b{constructor(t,e,n){this.connection=t,this.wallet=e,this.opts=n}static defaultOptions(){return{preflightCommitment:"recent",commitment:"recent"}}static local(e,n){n=n||b.defaultOptions();const r=new t(e||"http://localhost:8899",n.preflightCommitment),o=S.local();return new b(r,o,n)}static env(){const e=require("process").env.ANCHOR_PROVIDER_URL;if(void 0===e)throw new Error("ANCHOR_PROVIDER_URL is not defined");const n=b.defaultOptions(),r=new t(e,n.commitment),o=S.local();return new b(r,o,n)}async send(t,n,r){void 0===n&&(n=[]),void 0===r&&(r=this.opts);const o=n.filter(t=>void 0!==t),s=[this.wallet.publicKey].concat(o.map(t=>t.publicKey));t.setSigners(...s),t.recentBlockhash=(await this.connection.getRecentBlockhash(r.preflightCommitment)).blockhash,await this.wallet.signTransaction(t),o.forEach(e=>{t.partialSign(e)});const a=t.serialize();return await e(this.connection,a,r)}async sendAll(t,n){void 0===n&&(n=this.opts);const r=await this.connection.getRecentBlockhash(n.preflightCommitment);let o=t.map(t=>{let e=t.tx,n=t.signers;void 0===n&&(n=[]);const o=n.filter(t=>void 0!==t),s=[this.wallet.publicKey].concat(o.map(t=>t.publicKey));return e.setSigners(...s),e.recentBlockhash=r.blockhash,o.forEach(t=>{e.partialSign(t)}),e});const s=await this.wallet.signAllTransactions(o),a=[];for(let t=0;t<o.length;t+=1){const r=s[t].serialize();a.push(await e(this.connection,r,n))}return a}async simulate(t,e,n){void 0===e&&(e=[]),void 0===n&&(n=this.opts);const r=e.filter(t=>void 0!==t),o=[this.wallet.publicKey].concat(r.map(t=>t.publicKey));return t.setSigners(...o),t.recentBlockhash=(await this.connection.getRecentBlockhash(n.preflightCommitment)).blockhash,await this.wallet.signTransaction(t),r.forEach(e=>{t.partialSign(e)}),await async function(t,e,n){e.recentBlockhash=await t._recentBlockhash(t._disableBlockhashCaching);const r=e.serializeMessage(),o=[e._serialize(r).toString("base64"),{encoding:"base64",commitment:n}],s=await t._rpcRequest("simulateTransaction",o);if(s.error)throw new Error("failed to simulate transaction: "+s.error.message);return s.result}(this.connection,t,n.commitment)}}class S{constructor(t){this.payer=t}static local(){const t=new n(Buffer.from(JSON.parse(require("fs").readFileSync(require("os").homedir()+"/.config/solana/id.json",{encoding:"utf-8"}))));return new S(t)}async signTransaction(t){return t.partialSign(this.payer),t}async signAllTransactions(t){return t.map(t=>(t.partialSign(this.payer),t))}get publicKey(){return this.payer.publicKey}}class k extends Error{}class A extends Error{constructor(t,e,...n){super(...n),this.code=t,this.msg=e}toString(){return this.msg}}class E{constructor(t){this.instruction=new L(t),this.accounts=new B(t),this.types=new _(t),this.events=new I(t),t.state&&(this.state=new x(t))}sighash(t,e){return C(t,e)}}class L{constructor(t){this.ixLayout=L.parseIxLayout(t)}encode(t,e){return this._encode("global",t,e)}encodeState(t,e){return this._encode("state",t,e)}_encode(t,e,n){const r=Buffer.alloc(1e3),o=u(e),s=this.ixLayout.get(o).encode(n,r),a=r.slice(0,s);return Buffer.concat([C(t,e),a])}static parseIxLayout(t){const e=(t.state?t.state.methods:[]).map(e=>{let n=e.args.map(e=>K.fieldLayout(e,t.types));const r=u(e.name);return[r,f.struct(n,r)]}).concat(t.instructions.map(e=>{let n=e.args.map(e=>K.fieldLayout(e,t.types));const r=u(e.name);return[r,f.struct(n,r)]}));return new Map(e)}}class B{constructor(t){if(void 0===t.accounts)return void(this.accountLayouts=new Map);const e=t.accounts.map(e=>[e.name,K.typeDefLayout(e,t.types)]);this.accountLayouts=new Map(e)}async encode(t,e){const n=Buffer.alloc(1e3),r=this.accountLayouts.get(t).encode(e,n);let o=n.slice(0,r),s=await P(t);return Buffer.concat([s,o])}decode(t,e){const n=e.slice(8);return this.accountLayouts.get(t).decode(n)}}class _{constructor(t){if(void 0===t.types)return void(this.layouts=new Map);const e=t.types.map(e=>[e.name,K.typeDefLayout(e,t.types)]);this.layouts=new Map(e)}encode(t,e){const n=Buffer.alloc(1e3),r=this.layouts.get(t).encode(e,n);return n.slice(0,r)}decode(t,e){return this.layouts.get(t).decode(e)}}class I{constructor(t){if(void 0===t.events)return void(this.layouts=new Map);const e=t.events.map(e=>{let n={name:e.name,type:{kind:"struct",fields:e.fields.map(t=>({name:t.name,type:t.type}))}};return[e.name,K.typeDefLayout(n,t.types)]});this.layouts=new Map(e)}encode(t,e){const n=Buffer.alloc(1e3),r=this.layouts.get(t).encode(e,n);return n.slice(0,r)}decode(t,e){return this.layouts.get(t).decode(e)}}class x{constructor(t){if(void 0===t.state)throw new Error("Idl state not defined.");this.layout=K.typeDefLayout(t.state.struct,t.types)}async encode(t,e){const n=Buffer.alloc(1e3),r=this.layout.encode(e,n),o=await $(t),s=n.slice(0,r);return Buffer.concat([o,s])}decode(t){const e=t.slice(8);return this.layout.decode(e)}}class K{static fieldLayout(t,e){const n=void 0!==t.name?u(t.name):void 0;switch(t.type){case"bool":return f.bool(n);case"u8":return f.u8(n);case"u16":return f.u16(n);case"u32":return f.u32(n);case"u64":return f.u64(n);case"i64":return f.i64(n);case"u128":return f.u128(n);case"i128":return f.i128(n);case"bytes":return f.vecU8(n);case"string":return f.str(n);case"publicKey":return f.publicKey(n);default:if(t.type.vec)return f.vec(K.fieldLayout({name:void 0,type:t.type.vec},e),n);if(t.type.option)return f.option(K.fieldLayout({name:void 0,type:t.type.option},e),n);if(t.type.defined){if(void 0===e)throw new k("User defined types not provided");const r=e.filter(e=>e.name===t.type.defined);if(1!==r.length)throw new k(`Type not found: ${JSON.stringify(t)}`);return K.typeDefLayout(r[0],e,n)}if(t.type.array){let r=t.type.array[1],o=K.fieldLayout({name:void 0,type:t.type.array[0]},e);return f.array(o,r,n)}throw new Error(`Not yet implemented: ${t}`)}}static typeDefLayout(t,e,n){if("struct"===t.type.kind){const r=t.type.fields.map(t=>K.fieldLayout(t,e));return f.struct(r,n)}if("enum"===t.type.kind){let r=t.type.variants.map(t=>{const n=u(t.name);if(void 0===t.fields)return f.struct([],n);const r=t.fields.map(t=>{if(void 0===t.name)throw new Error("Tuple enum variants not yet implemented.");return K.fieldLayout(t,e)});return f.struct(r,n)});return void 0!==n?f.rustEnum(r).replicate(n):f.rustEnum(r,n)}throw new Error(`Unknown type kint: ${t}`)}}async function P(t){return Buffer.from(d.digest(`account:${t}`)).slice(0,8)}async function $(t){return Buffer.from(d.digest(`account:${t}`)).slice(0,8)}function M(t,e){switch(e){case"bool":case"u8":case"i8":return 1;case"u16":return 2;case"u32":return 4;case"u64":case"i64":return 8;case"u128":case"i128":return 16;case"bytes":case"string":return 1;case"publicKey":return 32;default:if(void 0!==e.vec)return 1;if(void 0!==e.option)return 1+M(t,e.option);if(void 0!==e.defined){const n=t.types.filter(t=>t.name===e.defined);if(1!==n.length)throw new k(`Type not found: ${JSON.stringify(e)}`);return T(t,n[0])}if(void 0!==e.array){let n=e.array[1];return M(t,e.array[0])*n}throw new Error(`Invalid type ${JSON.stringify(e)}`)}}function T(t,e){if("enum"===e.type.kind){let n=e.type.variants.map(e=>void 0===e.fields?0:e.fields.map(e=>{if(void 0===e.name)throw new Error("Tuple enum variants not yet implemented.");return M(t,e.type)}).reduce((t,e)=>t+e));return Math.max(...n)+1}return void 0===e.type.fields?0:e.type.fields.map(e=>M(t,e.type)).reduce((t,e)=>t+e)}function C(t,e){let n=l(e);return Buffer.from(d.digest(`${t}::${n}`)).slice(0,8)}async function O(t){const e=(await r.findProgramAddress([],t))[0];return await r.createWithSeed(e,"anchor:idl",t)}const R=f.struct([f.publicKey("authority"),f.vecU8("data")]);function W(t,...e){if(t.args.length!=e.length)throw new Error("Invalid argument length");const n={};let r=0;return t.args.forEach(t=>{n[t.name]=e[r],r+=1}),n}function D(t,e){t.forEach(t=>{if(void 0!==t.accounts)D(t.accounts,e[t.name]);else if(void 0===e[t.name])throw new Error(`Invalid arguments: ${t.name} not provided.`)})}function N(t,e){let n=e.toString().split("custom program error: ");if(2===n.length)try{const e=parseInt(n[1]);let r=t.get(e);return void 0===r?null:new A(e,r)}catch(t){return null}}function q(t,e){let n={};const r=t.args?t.args.length:0;if(e.length>r){if(e.length!==r+1)throw new Error("provided too many arguments ${args}");n=e.pop()}return[e,n]}class j{static build(t,e,n){if("_inner"===t.name)throw new k("the _inner name is reserved");const r=(...r)=>{const[s,a]=q(t,[...r]);D(t.accounts,a.accounts);const i=j.accountsArray(a.accounts,t.accounts);return void 0!==a.remainingAccounts&&i.push(...a.remainingAccounts),a.__private&&a.__private.logAccounts&&console.log("Outgoing account metas:",i),new o({keys:i,programId:n,data:e.instruction.encode(t.name,W(t,...s))})};return r.accounts=e=>j.accountsArray(e,t.accounts),r}static accountsArray(t,e){return e.map(e=>{const n=e.accounts;return void 0!==n?j.accountsArray(t[e.name],n).flat():{pubkey:t[e.name],isWritable:e.isMut,isSigner:e.isSigner}}).flat()}}async function J(t){let[e,n]=await r.findProgramAddress([],t);return r.createWithSeed(e,"unversioned",t)}const U=new Map,z="Program log: ".length;class F{constructor(t,e,n){this.coder=t,this.programId=e,this.discriminators=new Map(void 0===n.events?[]:n.events.map(t=>{return[g.fromByteArray((e=t.name,Buffer.from(d.digest(`event:${e}`)).slice(0,8))),t.name];var e}))}parseLogs(t,e){const n=new H(t),r=new V(n.next());let o=n.next();for(;null!==o;){let[t,s,a]=this.handleLog(r,o);t&&e(t),s&&r.push(s),a&&(r.pop(),n.next()),o=n.next()}}handleLog(t,e){return t.program()===this.programId.toString()?this.handleProgramLog(e):[null,...this.handleSystemLog(e)]}handleProgramLog(t){if(t.startsWith("Program log:")){const e=t.slice(z),n=Buffer.from(g.toByteArray(e)),r=g.fromByteArray(n.slice(0,8));let o=null,s=this.discriminators.get(r);return void 0!==s&&(o={name:s,data:this.coder.events.decode(s,n.slice(8))}),[o,null,!1]}return[null,...this.handleSystemLog(t)]}handleSystemLog(t){const e=t.split(":")[0];return e.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:e.includes("invoke")?["cpi",!1]:null!==e.match(/^Program (.*) consumed .*$/g)?[null,!0]:[null,!1]}}class V{constructor(t){const e=/^Program (.*) invoke.*$/g.exec(t)[1];this.stack=[e]}program(){return y.ok(this.stack.length>0),this.stack[this.stack.length-1]}push(t){this.stack.push(t)}pop(){y.ok(this.stack.length>0),this.stack.pop()}}class H{constructor(t){this.logs=t}next(){if(0===this.logs.length)return null;let t=this.logs[0];return this.logs=this.logs.slice(1),t}}new r("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");const Q={bs58:h,sha256:v,getMultipleAccounts:async function(t,e){const n=[e.map(t=>t.toBase58()),{commitment:"recent"}],o=await t._rpcRequest("getMultipleAccounts",n);if(o.error)throw new Error("failed to get info about accounts "+e.map(t=>t.toBase58()).join(", ")+": "+o.error.message);w(void 0!==o.result);const s=[];for(const t of o.result.value){let e=null;if(null!==t){if(o.result.value){const{executable:n,owner:o,lamports:s,data:a}=t;w("base64"===a[1]),e={executable:n,owner:new r(o),lamports:s,data:Buffer.from(a[0],"base64")}}if(null===e)throw new Error("Invalid response");s.push(e)}else s.push(null)}return s.map((t,n)=>null===t?null:{publicKey:e[n],account:t})},idlAddress:O};class G{constructor(t,e,n){this._idl=t,this._programId=e,this._provider=null!=n?n:et(),this._coder=new E(t);const[c,l,d,f,m,g]=class{static build(t,e,n,c){const l=function(t){const e=new Map;return t.errors&&t.errors.forEach(t=>{var n;let r=null!=(n=t.msg)?n:t.name;e.set(t.code,r)}),e}(t),d={},f={},m={},g={},y=class{static build(t,e,n,c,u){if(void 0===t.state)return;const l=async function(){const r=await J(n),o=await u.connection.getAccountInfo(r);if(null===o)throw new Error(`Account does not exist ${r.toString()}`);if((await $(t.state.struct.name)).compare(o.data.slice(0,8)))throw new Error("Invalid account discriminator");return e.state.decode(o.data)},d={},f={};t.state.methods.forEach(t=>{const l=async function(e){return(await async function(t,e,n,o){if("new"===n.name){const[n,o]=await r.findProgramAddress([],t);return[{pubkey:e.wallet.publicKey,isWritable:!1,isSigner:!0},{pubkey:await J(t),isWritable:!0,isSigner:!1},{pubkey:n,isWritable:!1,isSigner:!1},{pubkey:a.programId,isWritable:!1,isSigner:!1},{pubkey:t,isWritable:!1,isSigner:!1},{pubkey:i,isWritable:!1,isSigner:!1}]}return D(n.accounts,o),[{pubkey:await J(t),isWritable:!0,isSigner:!1}]}(n,u,t,e)).concat(j.accountsArray(e,t.accounts))},m=async function(...r){const[s,a]=q(t,[...r]);return new o({keys:await l(a.accounts),programId:n,data:e.instruction.encodeState(t.name,W(t,...s))})};m.accounts=l,f[t.name]=m,d[t.name]=async function(...e){const[n,r]=q(t,[...e]),o=new s;void 0!==r.instructions&&o.add(...r.instructions),o.add(await f[t.name](...e));try{return await u.send(o,r.signers,r.options)}catch(t){let e=N(c,t);if(null===e)throw t;throw e}}}),l.rpc=d,l.instruction=f,l.address=async function(){return J(n)};let m=null;return l.subscribe=t=>{if(null!==m)return m.ee;const n=new p;return l.address().then(r=>{const o=u.connection.onAccountChange(r,t=>{const r=e.state.decode(t.data);n.emit("change",r)},t);m={ee:n,listener:o}}),n},l.unsubscribe=()=>{null!==m&&u.connection.removeAccountChangeListener(m.listener).then(async function(){m=null}).catch(console.error)},l}}.build(t,e,n,l,c);t.instructions.forEach(r=>{const o=j.build(r,e,n),a=class{static build(t,e){return(...n)=>{const[r,o]=q(t,[...n]),a=new s;return void 0!==o.instructions&&a.add(...o.instructions),a.add(e(...n)),a}}}.build(r,o),i=class{static build(t,e,n,r){return async function(...o){const s=e(...o),[a,i]=q(t,[...o]);try{return await r.send(s,i.signers,i.options)}catch(t){console.log("Translating error",t);let e=N(n,t);if(null===e)throw t;throw e}}}}.build(r,a,l,c),p=class{static build(t,e,n,r,o,s,a){return async function(...i){const c=e(...i),[u,l]=q(t,[...i]);let d;try{d=await r.simulate(c,l.signers,l.options)}catch(t){console.log("Translating error",t);let e=N(n,t);if(null===e)throw t;throw e}if(void 0===d)throw new Error("Unable to simulate transaction");if(d.value.err)throw new Error(`Simulate error: ${d.value.err.toString()}`);const f=d.value.logs;if(!f)throw new Error("Simulated logs not found");const m=[];return a.events&&new F(o,s,a).parseLogs(f,t=>{m.push(t)}),{events:m,raw:f}}}}.build(r,a,l,c,e,n,t),h=u(r.name);f[h]=o,m[h]=a,d[h]=i,g[h]=p});const w=t.accounts?class{static build(t,e,n,o){const s={};return t.accounts.forEach(i=>{const c=u(i.name),l=async function(t){const n=await o.connection.getAccountInfo(t);if(null===n)throw new Error(`Account does not exist ${t.toString()}`);if((await P(i.name)).compare(n.data.slice(0,8)))throw new Error("Invalid account discriminator");return e.accounts.decode(i.name,n.data)};l.size=8+T(t,i),l.createInstruction=async function(t,e){const r=l.size;return a.createAccount({fromPubkey:o.wallet.publicKey,newAccountPubkey:t.publicKey,space:null!=e?e:r,lamports:await o.connection.getMinimumBalanceForRentExemption(null!=e?e:r),programId:n})},l.subscribe=(t,n)=>{if(U.get(t.toString()))return U.get(t.toString()).ee;const r=new p,s=o.connection.onAccountChange(t,t=>{const n=e.accounts.decode(i.name,t.data);r.emit("change",n)},n);return U.set(t.toString(),{ee:r,listener:s}),r},l.unsubscribe=t=>{let e=U.get(t.toString());e?U&&o.connection.removeAccountChangeListener(e.listener).then(()=>{U.delete(t.toString())}).catch(console.error):console.warn("Address is not subscribed")},l.all=async function(t){let s=await P(i.name);void 0!==t&&(s=Buffer.concat([s,t]));let a=await o.connection._rpcRequest("getProgramAccounts",[n.toBase58(),{commitment:o.connection.commitment,filters:[{memcmp:{offset:0,bytes:h.encode(s)}}]}]);if(a.error)throw console.error(a),new Error("Failed to get accounts");return a.result.map(({pubkey:t,account:{data:n}})=>(n=h.decode(n),{publicKey:new r(t),account:e.accounts.decode(i.name,n)}))},l.associatedAddress=async function(...t){let e=[Buffer.from([97,110,99,104,111,114])];t.forEach(t=>{e.push(t.toBuffer())});const[o]=await r.findProgramAddress(e,n);return o},l.associated=async function(...t){const e=await l.associatedAddress(...t);return await l(e)},s[c]=l}),s}}.build(t,e,n,c):{};return[d,f,m,w,y,g]}}.build(t,this._coder,e,this._provider);this.rpc=c,this.instruction=l,this.transaction=d,this.account=f,this.state=m,this.simulate=g}get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}static async at(t,e){const n=await G.fetchIdl(t,e);return new G(n,t,e)}static async fetchIdl(t,e){var n;e=null!=(n=e)?n:et();const r=await O(t);let o=(s=(await e.connection.getAccountInfo(r)).data.slice(8),R.decode(s));var s;const a=m(o.data);return JSON.parse((i=a,("undefined"==typeof TextDecoder?new(require("util").TextDecoder)("utf-8"):new TextDecoder("utf-8")).decode(i)));var i}addEventListener(t,e){const n=new F(this._coder,this._programId,this._idl);return this._provider.connection.onLogs(this._programId,(r,o)=>{r.err?console.error(r):n.parseLogs(r.logs,n=>{n.name===t&&e(n.data,o.slot)})})}async removeEventListener(t){return this._provider.connection.removeOnLogsListener(t)}}let X=!1;const Z=new Proxy({},{get(t,e){const n=require("find"),o=require("fs"),s=require("process");if("undefined"==typeof window){if(!X){const e=require("path");let a=s.cwd();for(;!o.existsSync(e.join(a,"Anchor.toml"));){const t=e.dirname(a);t===a&&(a=void 0),a=t}if(void 0===a)throw new Error("Could not find workspace root.");n.fileSync(/target\/idl\/.*\.json/,a).reduce((t,e)=>{const n=o.readFileSync(e),s=JSON.parse(n);return t[u(s.name,{pascalCase:!0})]=new G(s,new r(s.metadata.address)),t},t),X=!0}return t[e]}}});let Y=null;function tt(t){Y=t}function et(){return null===Y?b.local():Y}export{E as Coder,G as Program,b as Provider,S as Wallet,et as getProvider,tt as setProvider,Q as utils,Z as workspace};
//# sourceMappingURL=index.modern.js.map
