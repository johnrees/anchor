{"version":3,"file":"index.js","sources":["../src/provider.ts","../src/error.ts","../src/coder.ts","../src/idl.ts","../src/program/common.ts","../src/program/context.ts","../src/program/namespace/instruction.ts","../src/program/namespace/state.ts","../src/program/namespace/transaction.ts","../src/program/namespace/rpc.ts","../src/program/namespace/account.ts","../src/program/event.ts","../src/program/namespace/simulate.ts","../src/program/namespace/index.ts","../src/utils.ts","../src/program/index.ts","../src/workspace.ts","../src/index.ts"],"sourcesContent":["import {\n  Connection,\n  Account,\n  PublicKey,\n  Transaction,\n  TransactionSignature,\n  ConfirmOptions,\n  sendAndConfirmRawTransaction,\n  RpcResponseAndContext,\n  SimulatedTransactionResponse,\n  Commitment,\n} from \"@solana/web3.js\";\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nexport default class Provider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(\n    readonly connection: Connection,\n    readonly wallet: Wallet,\n    readonly opts: ConfirmOptions\n  ) {}\n\n  static defaultOptions(): ConfirmOptions {\n    return {\n      preflightCommitment: \"recent\",\n      commitment: \"recent\",\n    };\n  }\n\n  /**\n   * Returns a `Provider` with a wallet read from the local filesystem.\n   *\n   * @param url  The network cluster url.\n   * @param opts The default transaction confirmation options.\n   *\n   * (This api is for Node only.)\n   */\n  static local(url?: string, opts?: ConfirmOptions): Provider {\n    opts = opts || Provider.defaultOptions();\n    const connection = new Connection(\n      url || \"http://localhost:8899\",\n      opts.preflightCommitment\n    );\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, opts);\n  }\n\n  /**\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` envirnment\n   * variable\n   *\n   * (This api is for Node only.)\n   */\n  static env(): Provider {\n    const process = require(\"process\");\n    const url = process.env.ANCHOR_PROVIDER_URL;\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n    const options = Provider.defaultOptions();\n    const connection = new Connection(url, options.commitment);\n    const wallet = NodeWallet.local();\n\n    return new Provider(connection, wallet, options);\n  }\n\n  /**\n   * Sends the given transaction, ppaid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async send(\n    tx: Transaction,\n    signers?: Array<Account | undefined>,\n    opts?: ConfirmOptions\n  ): Promise<TransactionSignature> {\n    if (signers === undefined) {\n      signers = [];\n    }\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    const signerKps = signers.filter((s) => s !== undefined) as Array<Account>;\n    const signerPubkeys = [this.wallet.publicKey].concat(\n      signerKps.map((s) => s.publicKey)\n    );\n\n    tx.setSigners(...signerPubkeys);\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(opts.preflightCommitment)\n    ).blockhash;\n\n    await this.wallet.signTransaction(tx);\n    signerKps.forEach((kp) => {\n      tx.partialSign(kp);\n    });\n\n    const rawTx = tx.serialize();\n\n    const txId = await sendAndConfirmRawTransaction(\n      this.connection,\n      rawTx,\n      opts\n    );\n\n    return txId;\n  }\n\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n  async sendAll(\n    reqs: Array<SendTxRequest>,\n    opts?: ConfirmOptions\n  ): Promise<Array<TransactionSignature>> {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    const blockhash = await this.connection.getRecentBlockhash(\n      opts.preflightCommitment\n    );\n\n    let txs = reqs.map((r) => {\n      let tx = r.tx;\n      let signers = r.signers;\n\n      if (signers === undefined) {\n        signers = [];\n      }\n\n      const signerKps = signers.filter(\n        (s) => s !== undefined\n      ) as Array<Account>;\n      const signerPubkeys = [this.wallet.publicKey].concat(\n        signerKps.map((s) => s.publicKey)\n      );\n\n      tx.setSigners(...signerPubkeys);\n      tx.recentBlockhash = blockhash.blockhash;\n      signerKps.forEach((kp) => {\n        tx.partialSign(kp);\n      });\n\n      return tx;\n    });\n\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n\n    const sigs = [];\n\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(\n        await sendAndConfirmRawTransaction(this.connection, rawTx, opts)\n      );\n    }\n\n    return sigs;\n  }\n\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async simulate(\n    tx: Transaction,\n    signers?: Array<Account | undefined>,\n    opts?: ConfirmOptions\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (signers === undefined) {\n      signers = [];\n    }\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    const signerKps = signers.filter((s) => s !== undefined) as Array<Account>;\n    const signerPubkeys = [this.wallet.publicKey].concat(\n      signerKps.map((s) => s.publicKey)\n    );\n\n    tx.setSigners(...signerPubkeys);\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(opts.preflightCommitment)\n    ).blockhash;\n\n    await this.wallet.signTransaction(tx);\n    signerKps.forEach((kp) => {\n      tx.partialSign(kp);\n    });\n    return await simulateTransaction(this.connection, tx, opts.commitment);\n  }\n}\n\nexport type SendTxRequest = {\n  tx: Transaction;\n  signers: Array<Account | undefined>;\n};\n\n/**\n * Wallet interface for objects that can be used to sign provider transactions.\n */\nexport interface Wallet {\n  signTransaction(tx: Transaction): Promise<Transaction>;\n  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;\n  publicKey: PublicKey;\n}\n\n/**\n * Node only wallet.\n */\nexport class NodeWallet implements Wallet {\n  constructor(readonly payer: Account) {}\n\n  static local(): NodeWallet {\n    const payer = new Account(\n      Buffer.from(\n        JSON.parse(\n          require(\"fs\").readFileSync(\n            require(\"os\").homedir() + \"/.config/solana/id.json\",\n            {\n              encoding: \"utf-8\",\n            }\n          )\n        )\n      )\n    );\n    return new NodeWallet(payer);\n  }\n\n  async signTransaction(tx: Transaction): Promise<Transaction> {\n    tx.partialSign(this.payer);\n    return tx;\n  }\n\n  async signAllTransactions(txs: Transaction[]): Promise<Transaction[]> {\n    return txs.map((t) => {\n      t.partialSign(this.payer);\n      return t;\n    });\n  }\n\n  get publicKey(): PublicKey {\n    return this.payer.publicKey;\n  }\n}\n\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n","export class IdlError extends Error {}\n\n// An error from a user defined program.\nexport class ProgramError extends Error {\n  constructor(readonly code: number, readonly msg: string, ...params: any[]) {\n    super(...params);\n  }\n\n  public toString(): string {\n    return this.msg;\n  }\n}\n","import camelCase from \"camelcase\";\nimport { snakeCase } from \"snake-case\";\nimport { Layout } from \"buffer-layout\";\nimport * as sha256 from \"js-sha256\";\nimport * as borsh from \"@project-serum/borsh\";\nimport {\n  Idl,\n  IdlField,\n  IdlTypeDef,\n  IdlEnumVariant,\n  IdlType,\n  IdlStateMethod,\n} from \"./idl\";\nimport { IdlError } from \"./error\";\n\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n\n/**\n * Coder provides a facade for encoding and decoding all IDL related objects.\n */\nexport default class Coder {\n  /**\n   * Instruction coder.\n   */\n  readonly instruction: InstructionCoder;\n\n  /**\n   * Account coder.\n   */\n  readonly accounts: AccountsCoder;\n\n  /**\n   * Types coder.\n   */\n  readonly types: TypesCoder;\n\n  /**\n   * Coder for state structs.\n   */\n  readonly state: StateCoder;\n\n  /**\n   * Coder for events.\n   */\n  readonly events: EventCoder;\n\n  constructor(idl: Idl) {\n    this.instruction = new InstructionCoder(idl);\n    this.accounts = new AccountsCoder(idl);\n    this.types = new TypesCoder(idl);\n    this.events = new EventCoder(idl);\n    if (idl.state) {\n      this.state = new StateCoder(idl);\n    }\n  }\n\n  public sighash(nameSpace: string, ixName: string): Buffer {\n    return sighash(nameSpace, ixName);\n  }\n}\n\n/**\n * Encodes and decodes program instructions.\n */\nclass InstructionCoder {\n  /**\n   * Instruction args layout. Maps namespaced method\n   */\n  private ixLayout: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n  }\n\n  /**\n   * Encodes a program instruction.\n   */\n  public encode(ixName: string, ix: any) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n\n  /**\n   * Encodes a program state instruction.\n   */\n  public encodeState(ixName: string, ix: any) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  private _encode(nameSpace: string, ixName: string, ix: any): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = camelCase(ixName);\n    const len = this.ixLayout.get(methodName).encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  private static parseIxLayout(idl: Idl): Map<string, Layout> {\n    const stateMethods = idl.state ? idl.state.methods : [];\n\n    const ixLayouts = stateMethods\n      .map((m: IdlStateMethod) => {\n        let fieldLayouts = m.args.map((arg: IdlField) => {\n          return IdlCoder.fieldLayout(arg, idl.types);\n        });\n        const name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })\n      .concat(\n        idl.instructions.map((ix) => {\n          let fieldLayouts = ix.args.map((arg: IdlField) =>\n            IdlCoder.fieldLayout(arg, idl.types)\n          );\n          const name = camelCase(ix.name);\n          return [name, borsh.struct(fieldLayouts, name)];\n        })\n      );\n    // @ts-ignore\n    return new Map(ixLayouts);\n  }\n}\n\n/**\n * Encodes and decodes account objects.\n */\nclass AccountsCoder {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private accountLayouts: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts: [string, Layout][] = idl.accounts.map((acc) => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n\n    this.accountLayouts = new Map(layouts);\n  }\n\n  public async encode<T = any>(\n    accountName: string,\n    account: T\n  ): Promise<Buffer> {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = await accountDiscriminator(accountName);\n    return Buffer.concat([discriminator, accountData]);\n  }\n\n  public decode<T = any>(accountName: string, ix: Buffer): T {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(8);\n    const layout = this.accountLayouts.get(accountName);\n    return layout.decode(data);\n  }\n}\n\n/**\n * Encodes and decodes user defined types.\n */\nclass TypesCoder {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private layouts: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.types === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n    const layouts = idl.types.map((acc) => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n\n    // @ts-ignore\n    this.layouts = new Map(layouts);\n  }\n\n  public encode<T = any>(accountName: string, account: T): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.layouts.get(accountName);\n    const len = layout.encode(account, buffer);\n    return buffer.slice(0, len);\n  }\n\n  public decode<T = any>(accountName: string, ix: Buffer): T {\n    const layout = this.layouts.get(accountName);\n    return layout.decode(ix);\n  }\n}\n\nclass EventCoder {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private layouts: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.events === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n    const layouts = idl.events.map((event) => {\n      let eventTypeDef: IdlTypeDef = {\n        name: event.name,\n        type: {\n          kind: \"struct\",\n          fields: event.fields.map((f) => {\n            return { name: f.name, type: f.type };\n          }),\n        },\n      };\n      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n    });\n    // @ts-ignore\n    this.layouts = new Map(layouts);\n  }\n\n  public encode<T = any>(eventName: string, account: T): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.layouts.get(eventName);\n    const len = layout.encode(account, buffer);\n    return buffer.slice(0, len);\n  }\n\n  public decode<T = any>(eventName: string, ix: Buffer): T {\n    const layout = this.layouts.get(eventName);\n    return layout.decode(ix);\n  }\n}\n\nclass StateCoder {\n  private layout: Layout;\n\n  public constructor(idl: Idl) {\n    if (idl.state === undefined) {\n      throw new Error(\"Idl state not defined.\");\n    }\n    this.layout = IdlCoder.typeDefLayout(idl.state.struct, idl.types);\n  }\n\n  public async encode<T = any>(name: string, account: T): Promise<Buffer> {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const len = this.layout.encode(account, buffer);\n\n    const disc = await stateDiscriminator(name);\n    const accData = buffer.slice(0, len);\n\n    return Buffer.concat([disc, accData]);\n  }\n\n  public decode<T = any>(ix: Buffer): T {\n    // Chop off discriminator.\n    const data = ix.slice(8);\n    return this.layout.decode(data);\n  }\n}\n\nclass IdlCoder {\n  public static fieldLayout(field: IdlField, types?: IdlTypeDef[]): Layout {\n    const fieldName =\n      field.name !== undefined ? camelCase(field.name) : undefined;\n    switch (field.type) {\n      case \"bool\": {\n        return borsh.bool(fieldName);\n      }\n      case \"u8\": {\n        return borsh.u8(fieldName);\n      }\n      case \"u16\": {\n        return borsh.u16(fieldName);\n      }\n      case \"u32\": {\n        return borsh.u32(fieldName);\n      }\n      case \"u64\": {\n        return borsh.u64(fieldName);\n      }\n      case \"i64\": {\n        return borsh.i64(fieldName);\n      }\n      case \"u128\": {\n        return borsh.u128(fieldName);\n      }\n      case \"i128\": {\n        return borsh.i128(fieldName);\n      }\n      case \"bytes\": {\n        return borsh.vecU8(fieldName);\n      }\n      case \"string\": {\n        return borsh.str(fieldName);\n      }\n      case \"publicKey\": {\n        return borsh.publicKey(fieldName);\n      }\n      // TODO: all the other types that need to be exported by the borsh package.\n      default: {\n        // @ts-ignore\n        if (field.type.vec) {\n          return borsh.vec(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                // @ts-ignore\n                type: field.type.vec,\n              },\n              types\n            ),\n            fieldName\n          );\n          // @ts-ignore\n        } else if (field.type.option) {\n          return borsh.option(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                // @ts-ignore\n                type: field.type.option,\n              },\n              types\n            ),\n            fieldName\n          );\n          // @ts-ignore\n        } else if (field.type.defined) {\n          // User defined type.\n          if (types === undefined) {\n            throw new IdlError(\"User defined types not provided\");\n          }\n          // @ts-ignore\n          const filtered = types.filter((t) => t.name === field.type.defined);\n          if (filtered.length !== 1) {\n            throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n          }\n          return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n          // @ts-ignore\n        } else if (field.type.array) {\n          // @ts-ignore\n          let arrayTy = field.type.array[0];\n          // @ts-ignore\n          let arrayLen = field.type.array[1];\n          let innerLayout = IdlCoder.fieldLayout(\n            {\n              name: undefined,\n              type: arrayTy,\n            },\n            types\n          );\n          return borsh.array(innerLayout, arrayLen, fieldName);\n        } else {\n          throw new Error(`Not yet implemented: ${field}`);\n        }\n      }\n    }\n  }\n\n  public static typeDefLayout(\n    typeDef: IdlTypeDef,\n    types: IdlTypeDef[],\n    name?: string\n  ): Layout {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map((field) => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map((variant: IdlEnumVariant) => {\n        const name = camelCase(variant.name);\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        }\n        // @ts-ignore\n        const fieldLayouts = variant.fields.map((f: IdlField | IdlType) => {\n          // @ts-ignore\n          if (f.name === undefined) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          }\n          // @ts-ignore\n          return IdlCoder.fieldLayout(f, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n}\n\n// Calculates unique 8 byte discriminator prepended to all anchor accounts.\nexport async function accountDiscriminator(name: string): Promise<Buffer> {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\n\n// Calculates unique 8 byte discriminator prepended to all anchor state accounts.\nexport async function stateDiscriminator(name: string): Promise<Buffer> {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\n\nexport function eventDiscriminator(name: string): Buffer {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`event:${name}`)).slice(0, 8);\n}\n\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl: Idl, ty: IdlType): number {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      }\n      // @ts-ignore\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      }\n      // @ts-ignore\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        const filtered = idl.types.filter((t) => t.name === ty.defined);\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n        let typeDef = filtered[0];\n\n        return accountSize(idl, typeDef);\n      }\n      // @ts-ignore\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        let arrayTy = ty.array[0];\n        // @ts-ignore\n        let arraySize = ty.array[1];\n        // @ts-ignore\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n}\n\nexport function accountSize(\n  idl: Idl,\n  idlAccount: IdlTypeDef\n): number | undefined {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(\n      (variant: IdlEnumVariant) => {\n        if (variant.fields === undefined) {\n          return 0;\n        }\n        // @ts-ignore\n        return (\n          variant.fields\n            // @ts-ignore\n            .map((f: IdlField | IdlType) => {\n              // @ts-ignore\n              if (f.name === undefined) {\n                throw new Error(\"Tuple enum variants not yet implemented.\");\n              }\n              // @ts-ignore\n              return typeSize(idl, f.type);\n            })\n            .reduce((a: number, b: number) => a + b)\n        );\n      }\n    );\n    return Math.max(...variantSizes) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields\n    .map((f) => typeSize(idl, f.type))\n    .reduce((a, b) => a + b);\n}\n\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace: string, ixName: string): Buffer {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}::${name}`;\n  // @ts-ignore\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n\nexport type Idl = {\n  version: string;\n  name: string;\n  instructions: IdlInstruction[];\n  state?: IdlState;\n  accounts?: IdlTypeDef[];\n  types?: IdlTypeDef[];\n  events?: IdlEvent[];\n  errors?: IdlErrorCode[];\n};\n\nexport type IdlEvent = {\n  name: string;\n  fields: IdlEventField[];\n};\n\nexport type IdlEventField = {\n  name: string;\n  type: IdlType;\n  index: boolean;\n};\n\nexport type IdlInstruction = {\n  name: string;\n  accounts: IdlAccountItem[];\n  args: IdlField[];\n};\n\n// IdlStateMethods are similar to instructions, except they only allow\n// for a single account, the state account.\nexport type IdlState = {\n  struct: IdlTypeDef;\n  methods: IdlStateMethod[];\n};\n\nexport type IdlStateMethod = IdlInstruction;\n\nexport type IdlAccountItem = IdlAccount | IdlAccounts;\n\nexport type IdlAccount = {\n  name: string;\n  isMut: boolean;\n  isSigner: boolean;\n};\n\n// A nested/recursive version of IdlAccount.\nexport type IdlAccounts = {\n  name: string;\n  accounts: IdlAccountItem[];\n};\n\nexport type IdlField = {\n  name: string;\n  type: IdlType;\n};\n\nexport type IdlTypeDef = {\n  name: string;\n  type: IdlTypeDefTy;\n};\n\ntype IdlTypeDefTy = {\n  kind: \"struct\" | \"enum\";\n  fields?: IdlTypeDefStruct;\n  variants?: IdlEnumVariant[];\n};\n\ntype IdlTypeDefStruct = Array<IdlField>;\n\nexport type IdlType =\n  | \"bool\"\n  | \"u8\"\n  | \"i8\"\n  | \"u16\"\n  | \"i16\"\n  | \"u32\"\n  | \"i32\"\n  | \"u64\"\n  | \"i64\"\n  | \"bytes\"\n  | \"string\"\n  | \"publicKey\"\n  | IdlTypeVec\n  | IdlTypeOption\n  | IdlTypeDefined;\n\nexport type IdlTypeVec = {\n  vec: IdlType;\n};\n\nexport type IdlTypeOption = {\n  option: IdlType;\n};\n\n// User defined type.\nexport type IdlTypeDefined = {\n  defined: string;\n};\n\nexport type IdlEnumVariant = {\n  name: string;\n  fields?: IdlEnumFields;\n};\n\ntype IdlEnumFields = IdlEnumFieldsNamed | IdlEnumFieldsTuple;\n\ntype IdlEnumFieldsNamed = IdlField[];\n\ntype IdlEnumFieldsTuple = IdlType[];\n\ntype IdlErrorCode = {\n  code: number;\n  name: string;\n  msg?: string;\n};\n\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId: PublicKey): Promise<PublicKey> {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n\n// Seed for generating the idlAddress.\nexport function seed(): string {\n  return \"anchor:idl\";\n}\n\n// The on-chain account of the IDL.\nexport interface IdlProgramAccount {\n  authority: PublicKey;\n  data: Buffer;\n}\n\nconst IDL_ACCOUNT_LAYOUT: borsh.Layout<IdlProgramAccount> = borsh.struct([\n  borsh.publicKey(\"authority\"),\n  borsh.vecU8(\"data\"),\n]);\n\nexport function decodeIdlAccount(data: Buffer): IdlProgramAccount {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n\nexport function encodeIdlAccount(acc: IdlProgramAccount): Buffer {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\n","import EventEmitter from \"eventemitter3\";\nimport { Idl, IdlInstruction, IdlAccountItem, IdlStateMethod } from \"../idl\";\nimport { ProgramError } from \"../error\";\nimport { Accounts } from \"./context\";\n\nexport type Subscription = {\n  listener: number;\n  ee: EventEmitter;\n};\n\nexport function parseIdlErrors(idl: Idl): Map<number, string> {\n  const errors = new Map();\n  if (idl.errors) {\n    idl.errors.forEach((e) => {\n      let msg = e.msg ?? e.name;\n      errors.set(e.code, msg);\n    });\n  }\n  return errors;\n}\n\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nexport function toInstruction(\n  idlIx: IdlInstruction | IdlStateMethod,\n  ...args: any[]\n) {\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n  const ix: { [key: string]: any } = {};\n  let idx = 0;\n  idlIx.args.forEach((ixArg) => {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n\n  return ix;\n}\n\n// Throws error if any account required for the `ix` is not given.\nexport function validateAccounts(\n  ixAccounts: IdlAccountItem[],\n  accounts: Accounts\n) {\n  ixAccounts.forEach((acc) => {\n    // @ts-ignore\n    if (acc.accounts !== undefined) {\n      // @ts-ignore\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n      }\n    }\n  });\n}\n\nexport function translateError(\n  idlErrors: Map<number, string>,\n  err: any\n): Error | null {\n  // TODO: don't rely on the error string. web3.js should preserve the error\n  //       code information instead of giving us an untyped string.\n  let components = err.toString().split(\"custom program error: \");\n  if (components.length === 2) {\n    try {\n      const errorCode = parseInt(components[1]);\n      let errorMsg = idlErrors.get(errorCode);\n      if (errorMsg === undefined) {\n        // Unexpected error code so just throw the untranslated error.\n        return null;\n      }\n      return new ProgramError(errorCode, errorMsg);\n    } catch (parseErr) {\n      // Unable to parse the error. Just return the untranslated error.\n      return null;\n    }\n  }\n}\n","import {\n  Account,\n  AccountMeta,\n  PublicKey,\n  ConfirmOptions,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { IdlInstruction } from \"../idl\";\n\n/**\n * Context provides all non-argument inputs for generating Anchor transactions.\n */\nexport type Context = {\n  /**\n   * Accounts used in the instruction context.\n   */\n  accounts?: Accounts;\n\n  /**\n   * All accounts to pass into an instruction *after* the main `accounts`.\n   * This can be used for optional or otherwise unknown accounts.\n   */\n  remainingAccounts?: AccountMeta[];\n\n  /**\n   * Accounts that must sign a given transaction.\n   */\n  signers?: Array<Account>;\n\n  /**\n   * Instructions to run *before* a given method. Often this is used, for\n   * example to create accounts prior to executing a method.\n   */\n  instructions?: TransactionInstruction[];\n\n  /**\n   * Commitment parameters to use for a transaction.\n   */\n  options?: ConfirmOptions;\n\n  /**\n   * @hidden\n   *\n   * Private namespace for development.\n   */\n  __private?: { logAccounts: boolean };\n};\n\n/**\n * A set of accounts mapping one-to-one to the program's accounts struct, i.e.,\n * the type deriving `#[derive(Accounts)]`.\n *\n * The name of each field should match the name for that account in the IDL.\n *\n * If multiple accounts are nested in the rust program, then they should be\n * nested here.\n */\nexport type Accounts = {\n  [key: string]: PublicKey | Accounts;\n};\n\nexport function splitArgsAndCtx(\n  idlIx: IdlInstruction,\n  args: any[]\n): [any[], Context] {\n  let options = {};\n\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(\"provided too many arguments ${args}\");\n    }\n    options = args.pop();\n  }\n\n  return [args, options];\n}\n","import { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlAccount, IdlInstruction, IdlAccountItem } from \"../../idl\";\nimport { IdlError } from \"../../error\";\nimport Coder from \"../../coder\";\nimport { toInstruction, validateAccounts } from \"../common\";\nimport { Accounts, splitArgsAndCtx } from \"../context\";\n\n/**\n * Dynamically generated instruction namespace.\n */\nexport interface InstructionNamespace {\n  [key: string]: IxFn;\n}\n\n/**\n * Ix is a function to create a `TransactionInstruction` generated from an IDL.\n */\nexport type IxFn = IxProps & ((...args: any[]) => any);\ntype IxProps = {\n  accounts: (ctx: Accounts) => any;\n};\n\nexport default class InstructionNamespaceFactory {\n  // Builds the instuction namespace.\n  public static build(\n    idlIx: IdlInstruction,\n    coder: Coder,\n    programId: PublicKey\n  ): IxFn {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = (...args: any[]): TransactionInstruction => {\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n\n      const keys = InstructionNamespaceFactory.accountsArray(\n        ctx.accounts,\n        idlIx.accounts\n      );\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (ctx.__private && ctx.__private.logAccounts) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: coder.instruction.encode(\n          idlIx.name,\n          toInstruction(idlIx, ...ixArgs)\n        ),\n      });\n    };\n\n    // Utility fn for ordering the accounts for this instruction.\n    ix[\"accounts\"] = (accs: Accounts) => {\n      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n    };\n\n    return ix;\n  }\n\n  public static accountsArray(ctx: Accounts, accounts: IdlAccountItem[]): any {\n    return accounts\n      .map((acc: IdlAccountItem) => {\n        // Nested accounts.\n        // @ts-ignore\n        const nestedAccounts: IdlAccountItem[] | undefined = acc.accounts;\n        if (nestedAccounts !== undefined) {\n          const rpcAccs = ctx[acc.name] as Accounts;\n          return InstructionNamespaceFactory.accountsArray(\n            rpcAccs,\n            nestedAccounts\n          ).flat();\n        } else {\n          const account: IdlAccount = acc as IdlAccount;\n          return {\n            pubkey: ctx[acc.name],\n            isWritable: account.isMut,\n            isSigner: account.isSigner,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix: IdlInstruction, ...args: any[]) {\n  // todo\n}\n","import EventEmitter from \"eventemitter3\";\nimport {\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionSignature,\n  TransactionInstruction,\n  SYSVAR_RENT_PUBKEY,\n  Commitment,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { Idl, IdlStateMethod } from \"../../idl\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { RpcNamespace, InstructionNamespace } from \"./\";\nimport {\n  Subscription,\n  translateError,\n  toInstruction,\n  validateAccounts,\n} from \"../common\";\nimport { Accounts, splitArgsAndCtx } from \"../context\";\nimport InstructionNamespaceFactory from \"./instruction\";\n\nexport type StateNamespace = () =>\n  | Promise<any>\n  | {\n      address: () => Promise<PublicKey>;\n      rpc: RpcNamespace;\n      instruction: InstructionNamespace;\n      subscribe: (address: PublicKey, commitment?: Commitment) => EventEmitter;\n      unsubscribe: (address: PublicKey) => void;\n    };\n\nexport default class StateFactory {\n  // Builds the state namespace.\n  public static build(\n    idl: Idl,\n    coder: Coder,\n    programId: PublicKey,\n    idlErrors: Map<number, string>,\n    provider: Provider\n  ): StateNamespace | undefined {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n\n    // Fetches the state object from the blockchain.\n    const state = async (): Promise<any> => {\n      const addr = await programStateAddress(programId);\n      const accountInfo = await provider.connection.getAccountInfo(addr);\n      if (accountInfo === null) {\n        throw new Error(`Account does not exist ${addr.toString()}`);\n      }\n      // Assert the account discriminator is correct.\n      const expectedDiscriminator = await stateDiscriminator(\n        idl.state.struct.name\n      );\n      if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n        throw new Error(\"Invalid account discriminator\");\n      }\n      return coder.state.decode(accountInfo.data);\n    };\n\n    // Namespace with all rpc functions.\n    const rpc: RpcNamespace = {};\n    const ix: InstructionNamespace = {};\n\n    idl.state.methods.forEach((m: IdlStateMethod) => {\n      const accounts = async (accounts: Accounts): Promise<any> => {\n        const keys = await stateInstructionKeys(\n          programId,\n          provider,\n          m,\n          accounts\n        );\n        return keys.concat(\n          InstructionNamespaceFactory.accountsArray(accounts, m.accounts)\n        );\n      };\n      const ixFn = async (...args: any[]): Promise<TransactionInstruction> => {\n        const [ixArgs, ctx] = splitArgsAndCtx(m, [...args]);\n        return new TransactionInstruction({\n          keys: await accounts(ctx.accounts),\n          programId,\n          data: coder.instruction.encodeState(\n            m.name,\n            toInstruction(m, ...ixArgs)\n          ),\n        });\n      };\n      ixFn[\"accounts\"] = accounts;\n      ix[m.name] = ixFn;\n\n      rpc[m.name] = async (...args: any[]): Promise<TransactionSignature> => {\n        const [_, ctx] = splitArgsAndCtx(m, [...args]);\n        const tx = new Transaction();\n        if (ctx.instructions !== undefined) {\n          tx.add(...ctx.instructions);\n        }\n        tx.add(await ix[m.name](...args));\n        try {\n          const txSig = await provider.send(tx, ctx.signers, ctx.options);\n          return txSig;\n        } catch (err) {\n          let translatedErr = translateError(idlErrors, err);\n          if (translatedErr === null) {\n            throw err;\n          }\n          throw translatedErr;\n        }\n      };\n    });\n\n    state[\"rpc\"] = rpc;\n    state[\"instruction\"] = ix;\n    // Calculates the address of the program's global state object account.\n    state[\"address\"] = async (): Promise<PublicKey> =>\n      programStateAddress(programId);\n\n    // Subscription singleton.\n    let sub: null | Subscription = null;\n\n    // Subscribe to account changes.\n    state[\"subscribe\"] = (commitment?: Commitment): EventEmitter => {\n      if (sub !== null) {\n        return sub.ee;\n      }\n      const ee = new EventEmitter();\n\n      state[\"address\"]().then((address) => {\n        const listener = provider.connection.onAccountChange(\n          address,\n          (acc) => {\n            const account = coder.state.decode(acc.data);\n            ee.emit(\"change\", account);\n          },\n          commitment\n        );\n\n        sub = {\n          ee,\n          listener,\n        };\n      });\n\n      return ee;\n    };\n\n    // Unsubscribe from account changes.\n    state[\"unsubscribe\"] = () => {\n      if (sub !== null) {\n        provider.connection\n          .removeAccountChangeListener(sub.listener)\n          .then(async () => {\n            sub = null;\n          })\n          .catch(console.error);\n      }\n    };\n\n    return state;\n  }\n}\n\n// Calculates the deterministic address of the program's \"state\" account.\nasync function programStateAddress(programId: PublicKey): Promise<PublicKey> {\n  let [registrySigner, _nonce] = await PublicKey.findProgramAddress(\n    [],\n    programId\n  );\n  return PublicKey.createWithSeed(registrySigner, \"unversioned\", programId);\n}\n\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nasync function stateInstructionKeys(\n  programId: PublicKey,\n  provider: Provider,\n  m: IdlStateMethod,\n  accounts: Accounts\n) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner, _nonce] = await PublicKey.findProgramAddress(\n      [],\n      programId\n    );\n    return [\n      {\n        pubkey: provider.wallet.publicKey,\n        isWritable: false,\n        isSigner: true,\n      },\n      {\n        pubkey: await programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n      { pubkey: programSigner, isWritable: false, isSigner: false },\n      {\n        pubkey: SystemProgram.programId,\n        isWritable: false,\n        isSigner: false,\n      },\n\n      { pubkey: programId, isWritable: false, isSigner: false },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isWritable: false,\n        isSigner: false,\n      },\n    ];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [\n      {\n        pubkey: await programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n    ];\n  }\n}\n","import { Transaction } from \"@solana/web3.js\";\nimport { IdlInstruction } from \"../../idl\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { IxFn } from \"./instruction\";\n\n/**\n * Dynamically generated transaction namespace.\n */\nexport interface TransactionNamespace {\n  [key: string]: TxFn;\n}\n\n/**\n * Tx is a function to create a `Transaction` generate from an IDL.\n */\nexport type TxFn = (...args: any[]) => Transaction;\n\nexport default class TransactionFactory {\n  // Builds the transaction namespace.\n  public static build(idlIx: IdlInstruction, ixFn: IxFn): TxFn {\n    const txFn = (...args: any[]): Transaction => {\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      const tx = new Transaction();\n      if (ctx.instructions !== undefined) {\n        tx.add(...ctx.instructions);\n      }\n      tx.add(ixFn(...args));\n      return tx;\n    };\n\n    return txFn;\n  }\n}\n","import { TransactionSignature } from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { IdlInstruction } from \"../../idl\";\nimport { translateError } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { TxFn } from \"./transaction\";\n\n/**\n * Dynamically generated rpc namespace.\n */\nexport interface RpcNamespace {\n  [key: string]: RpcFn;\n}\n\n/**\n * RpcFn is a single rpc method generated from an IDL.\n */\nexport type RpcFn = (...args: any[]) => Promise<TransactionSignature>;\n\nexport default class RpcFactory {\n  // Builds the rpc namespace.\n  public static build(\n    idlIx: IdlInstruction,\n    txFn: TxFn,\n    idlErrors: Map<number, string>,\n    provider: Provider\n  ): RpcFn {\n    const rpc = async (...args: any[]): Promise<TransactionSignature> => {\n      const tx = txFn(...args);\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      try {\n        const txSig = await provider.send(tx, ctx.signers, ctx.options);\n        return txSig;\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = translateError(idlErrors, err);\n        if (translatedErr === null) {\n          throw err;\n        }\n        throw translatedErr;\n      }\n    };\n\n    return rpc;\n  }\n}\n","import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport {\n  Account,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n  Commitment,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { Idl } from \"../../idl\";\nimport Coder, {\n  ACCOUNT_DISCRIMINATOR_SIZE,\n  accountDiscriminator,\n  accountSize,\n} from \"../../coder\";\nimport { Subscription } from \"../common\";\n\n/**\n * Accounts is a dynamically generated object to fetch any given account\n * of a program.\n */\nexport interface AccountNamespace {\n  [key: string]: AccountFn;\n}\n\n/**\n * Account is a function returning a deserialized account, given an address.\n */\nexport type AccountFn<T = any> = AccountProps & ((address: PublicKey) => T);\n\n/**\n * Non function properties on the acccount namespace.\n */\ntype AccountProps = {\n  size: number;\n  all: (filter?: Buffer) => Promise<ProgramAccount<any>[]>;\n  subscribe: (address: PublicKey, commitment?: Commitment) => EventEmitter;\n  unsubscribe: (address: PublicKey) => void;\n  createInstruction: (account: Account) => Promise<TransactionInstruction>;\n  associated: (...args: PublicKey[]) => Promise<any>;\n  associatedAddress: (...args: PublicKey[]) => Promise<PublicKey>;\n};\n\n/**\n * @hidden\n *\n * Deserialized account owned by a program.\n */\nexport type ProgramAccount<T = any> = {\n  publicKey: PublicKey;\n  account: T;\n};\n\n// Tracks all subscriptions.\nconst subscriptions: Map<string, Subscription> = new Map();\n\nexport default class AccountFactory {\n  // Returns the generated accounts namespace.\n  public static build(\n    idl: Idl,\n    coder: Coder,\n    programId: PublicKey,\n    provider: Provider\n  ): AccountNamespace {\n    const accountFns: AccountNamespace = {};\n\n    idl.accounts.forEach((idlAccount) => {\n      const name = camelCase(idlAccount.name);\n\n      // Fetches the decoded account from the network.\n      const accountsNamespace = async (address: PublicKey): Promise<any> => {\n        const accountInfo = await provider.connection.getAccountInfo(address);\n        if (accountInfo === null) {\n          throw new Error(`Account does not exist ${address.toString()}`);\n        }\n\n        // Assert the account discriminator is correct.\n        const discriminator = await accountDiscriminator(idlAccount.name);\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n          throw new Error(\"Invalid account discriminator\");\n        }\n\n        return coder.accounts.decode(idlAccount.name, accountInfo.data);\n      };\n\n      // Returns the size of the account.\n      // @ts-ignore\n      accountsNamespace[\"size\"] =\n        ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n\n      // Returns an instruction for creating this account.\n      // @ts-ignore\n      accountsNamespace[\"createInstruction\"] = async (\n        account: Account,\n        sizeOverride?: number\n      ): Promise<TransactionInstruction> => {\n        // @ts-ignore\n        const size = accountsNamespace[\"size\"];\n\n        return SystemProgram.createAccount({\n          fromPubkey: provider.wallet.publicKey,\n          newAccountPubkey: account.publicKey,\n          space: sizeOverride ?? size,\n          lamports: await provider.connection.getMinimumBalanceForRentExemption(\n            sizeOverride ?? size\n          ),\n          programId,\n        });\n      };\n\n      // Subscribes to all changes to this account.\n      // @ts-ignore\n      accountsNamespace[\"subscribe\"] = (\n        address: PublicKey,\n        commitment?: Commitment\n      ): EventEmitter => {\n        if (subscriptions.get(address.toString())) {\n          return subscriptions.get(address.toString()).ee;\n        }\n        const ee = new EventEmitter();\n\n        const listener = provider.connection.onAccountChange(\n          address,\n          (acc) => {\n            const account = coder.accounts.decode(idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n          },\n          commitment\n        );\n\n        subscriptions.set(address.toString(), {\n          ee,\n          listener,\n        });\n\n        return ee;\n      };\n\n      // Unsubscribes to account changes.\n      // @ts-ignore\n      accountsNamespace[\"unsubscribe\"] = (address: PublicKey) => {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n          console.warn(\"Address is not subscribed\");\n          return;\n        }\n        if (subscriptions) {\n          provider.connection\n            .removeAccountChangeListener(sub.listener)\n            .then(() => {\n              subscriptions.delete(address.toString());\n            })\n            .catch(console.error);\n        }\n      };\n\n      // Returns all instances of this account type for the program.\n      // @ts-ignore\n      accountsNamespace[\"all\"] = async (\n        filter?: Buffer\n      ): Promise<ProgramAccount<any>[]> => {\n        let bytes = await accountDiscriminator(idlAccount.name);\n        if (filter !== undefined) {\n          bytes = Buffer.concat([bytes, filter]);\n        }\n        // @ts-ignore\n        let resp = await provider.connection._rpcRequest(\"getProgramAccounts\", [\n          programId.toBase58(),\n          {\n            commitment: provider.connection.commitment,\n            filters: [\n              {\n                memcmp: {\n                  offset: 0,\n                  bytes: bs58.encode(bytes),\n                },\n              },\n            ],\n          },\n        ]);\n        if (resp.error) {\n          console.error(resp);\n          throw new Error(\"Failed to get accounts\");\n        }\n        return (\n          resp.result\n            // @ts-ignore\n            .map(({ pubkey, account: { data } }) => {\n              data = bs58.decode(data);\n              return {\n                publicKey: new PublicKey(pubkey),\n                account: coder.accounts.decode(idlAccount.name, data),\n              };\n            })\n        );\n      };\n\n      // Function returning the associated address. Args are keys to associate.\n      // Order matters.\n      accountsNamespace[\"associatedAddress\"] = async (\n        ...args: PublicKey[]\n      ): Promise<PublicKey> => {\n        let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n        args.forEach((arg) => {\n          seeds.push(arg.toBuffer());\n        });\n        const [assoc] = await PublicKey.findProgramAddress(seeds, programId);\n        return assoc;\n      };\n\n      // Function returning the associated account. Args are keys to associate.\n      // Order matters.\n      accountsNamespace[\"associated\"] = async (\n        ...args: PublicKey[]\n      ): Promise<any> => {\n        const addr = await accountsNamespace[\"associatedAddress\"](...args);\n        return await accountsNamespace(addr);\n      };\n\n      accountFns[name] = accountsNamespace;\n    });\n\n    return accountFns;\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport * as base64 from \"base64-js\";\nimport * as assert from \"assert\";\nimport Coder, { eventDiscriminator } from \"../coder\";\nimport { Idl } from \"../idl\";\n\nconst LOG_START_INDEX = \"Program log: \".length;\n\n// Deserialized event.\nexport type Event = {\n  name: string;\n  data: Object;\n};\n\nexport class EventParser {\n  private coder: Coder;\n  private programId: PublicKey;\n  // Maps base64 encoded event discriminator to event name.\n  private discriminators: Map<string, string>;\n\n  constructor(coder: Coder, programId: PublicKey, idl: Idl) {\n    this.coder = coder;\n    this.programId = programId;\n    this.discriminators = new Map<string, string>(\n      idl.events === undefined\n        ? []\n        : idl.events.map((e) => [\n            base64.fromByteArray(eventDiscriminator(e.name)),\n            e.name,\n          ])\n    );\n  }\n\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  public parseLogs(logs: string[], callback: (log: Event) => void) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext(logScanner.next() as string);\n    let log = logScanner.next();\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n      if (event) {\n        callback(event);\n      }\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n      if (didPop) {\n        execution.pop();\n        // Skip the \"success\" log, which always follows the consumed log.\n        logScanner.next();\n      }\n      log = logScanner.next();\n    }\n  }\n\n  // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n  private handleLog(\n    execution: ExecutionContext,\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // Executing program is this program.\n    if (execution.program() === this.programId.toString()) {\n      return this.handleProgramLog(log);\n    }\n    // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs from *this* program.\n  private handleProgramLog(\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // This is a `msg!` log.\n    if (log.startsWith(\"Program log:\")) {\n      const logStr = log.slice(LOG_START_INDEX);\n      const logArr = Buffer.from(base64.toByteArray(logStr));\n      const disc = base64.fromByteArray(logArr.slice(0, 8));\n      // Only deserialize if the discriminator implies a proper event.\n      let event = null;\n      let eventName = this.discriminators.get(disc);\n      if (eventName !== undefined) {\n        event = {\n          name: eventName,\n          data: this.coder.events.decode(eventName, logArr.slice(8)),\n        };\n      }\n      return [event, null, false];\n    }\n    // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs when the current program being executing is *not* this.\n  private handleSystemLog(log: string): [string | null, boolean] {\n    // System component.\n    const logStart = log.split(\":\")[0];\n    // Recursive call.\n    if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n      return [this.programId.toString(), false];\n    }\n    // Cpi call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      // Did the program finish executing?\n      if (logStart.match(/^Program (.*) consumed .*$/g) !== null) {\n        return [null, true];\n      }\n      return [null, false];\n    }\n  }\n}\n\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n  stack: string[];\n\n  constructor(log: string) {\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    const program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n\n  program(): string {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram: string) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n}\n\nclass LogScanner {\n  constructor(public logs: string[]) {}\n\n  next(): string | null {\n    if (this.logs.length === 0) {\n      return null;\n    }\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { IdlInstruction } from \"../../idl\";\nimport { translateError } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { TxFn } from \"./transaction\";\nimport { EventParser } from \"../event\";\nimport Coder from \"../../coder\";\nimport { Idl } from \"../../idl\";\n\n/**\n * Dynamically generated simualte namespace.\n */\nexport interface SimulateNamespace {\n  [key: string]: SimulateFn;\n}\n\n/**\n * RpcFn is a single rpc method generated from an IDL.\n */\nexport type SimulateFn = (...args: any[]) => Promise<SimulateResponse>;\n\ntype SimulateResponse = {\n  events: Event[];\n  raw: string[];\n};\n\nexport default class SimulateFactory {\n  // Builds the rpc namespace.\n  public static build(\n    idlIx: IdlInstruction,\n    txFn: TxFn,\n    idlErrors: Map<number, string>,\n    provider: Provider,\n    coder: Coder,\n    programId: PublicKey,\n    idl: Idl\n  ): SimulateFn {\n    const simulate = async (...args: any[]): Promise<SimulateResponse> => {\n      const tx = txFn(...args);\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      let resp = undefined;\n      try {\n        resp = await provider.simulate(tx, ctx.signers, ctx.options);\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = translateError(idlErrors, err);\n        if (translatedErr === null) {\n          throw err;\n        }\n        throw translatedErr;\n      }\n      if (resp === undefined) {\n        throw new Error(\"Unable to simulate transaction\");\n      }\n      if (resp.value.err) {\n        throw new Error(`Simulate error: ${resp.value.err.toString()}`);\n      }\n      const logs = resp.value.logs;\n      if (!logs) {\n        throw new Error(\"Simulated logs not found\");\n      }\n\n      const events = [];\n      if (idl.events) {\n        let parser = new EventParser(coder, programId, idl);\n        parser.parseLogs(logs, (event) => {\n          events.push(event);\n        });\n      }\n      return { events, raw: logs };\n    };\n\n    return simulate;\n  }\n}\n","import camelCase from \"camelcase\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport Coder from \"../../coder\";\nimport Provider from \"../../provider\";\nimport { Idl } from \"../../idl\";\nimport { parseIdlErrors } from \"../common\";\nimport StateFactory, { StateNamespace } from \"./state\";\nimport InstructionFactory, { InstructionNamespace } from \"./instruction\";\nimport TransactionFactory, { TransactionNamespace } from \"./transaction\";\nimport RpcFactory, { RpcNamespace } from \"./rpc\";\nimport AccountFactory, { AccountNamespace } from \"./account\";\nimport SimulateFactory, { SimulateNamespace } from \"./simulate\";\n\n// Re-exports.\nexport { StateNamespace } from \"./state\";\nexport { InstructionNamespace } from \"./instruction\";\nexport { TransactionNamespace, TxFn } from \"./transaction\";\nexport { RpcNamespace, RpcFn } from \"./rpc\";\nexport { AccountNamespace, AccountFn, ProgramAccount } from \"./account\";\nexport { SimulateNamespace } from \"./simulate\";\n\nexport default class NamespaceFactory {\n  /**\n   * Generates all namespaces for a given program.\n   */\n  public static build(\n    idl: Idl,\n    coder: Coder,\n    programId: PublicKey,\n    provider: Provider\n  ): [\n    RpcNamespace,\n    InstructionNamespace,\n    TransactionNamespace,\n    AccountNamespace,\n    StateNamespace,\n    SimulateNamespace\n  ] {\n    const idlErrors = parseIdlErrors(idl);\n\n    const rpc: RpcNamespace = {};\n    const instruction: InstructionNamespace = {};\n    const transaction: TransactionNamespace = {};\n    const simulate: SimulateNamespace = {};\n\n    const state = StateFactory.build(\n      idl,\n      coder,\n      programId,\n      idlErrors,\n      provider\n    );\n\n    idl.instructions.forEach((idlIx) => {\n      const ixItem = InstructionFactory.build(idlIx, coder, programId);\n      const txItem = TransactionFactory.build(idlIx, ixItem);\n      const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);\n      const simulateItem = SimulateFactory.build(\n        idlIx,\n        txItem,\n        idlErrors,\n        provider,\n        coder,\n        programId,\n        idl\n      );\n\n      const name = camelCase(idlIx.name);\n\n      instruction[name] = ixItem;\n      transaction[name] = txItem;\n      rpc[name] = rpcItem;\n      simulate[name] = simulateItem;\n    });\n\n    const account = idl.accounts\n      ? AccountFactory.build(idl, coder, programId, provider)\n      : {};\n\n    return [rpc, instruction, transaction, account, state, simulate];\n  }\n}\n","import * as bs58 from \"bs58\";\nimport { sha256 } from \"crypto-hash\";\nimport assert from \"assert\";\nimport { PublicKey, AccountInfo, Connection } from \"@solana/web3.js\";\nimport { idlAddress } from \"./idl\";\n\nexport const TOKEN_PROGRAM_ID = new PublicKey(\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nasync function getMultipleAccounts(\n  connection: Connection,\n  publicKeys: PublicKey[]\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (res.error) {\n    throw new Error(\n      \"failed to get info about accounts \" +\n        publicKeys.map((k) => k.toBase58()).join(\", \") +\n        \": \" +\n        res.error.message\n    );\n  }\n  assert(typeof res.result !== \"undefined\");\n  const accounts: Array<null | {\n    executable: any;\n    owner: PublicKey;\n    lamports: any;\n    data: Buffer;\n  }> = [];\n  for (const account of res.result.value) {\n    let value: {\n      executable: any;\n      owner: PublicKey;\n      lamports: any;\n      data: Buffer;\n    } | null = null;\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n    if (res.result.value) {\n      const { executable, owner, lamports, data } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\"),\n      };\n    }\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n    accounts.push(value);\n  }\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n    return {\n      publicKey: publicKeys[idx],\n      account,\n    };\n  });\n}\n\nexport function decodeUtf8(array: Uint8Array): string {\n  const decoder =\n    typeof TextDecoder === \"undefined\"\n      ? new (require(\"util\").TextDecoder)(\"utf-8\") // Node.\n      : new TextDecoder(\"utf-8\"); // Browser.\n  return decoder.decode(array);\n}\n\nconst utils = {\n  bs58,\n  sha256,\n  getMultipleAccounts,\n  idlAddress,\n};\n\nexport default utils;\n","import { inflate } from \"pako\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport Provider from \"../provider\";\nimport { Idl, idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory, {\n  RpcNamespace,\n  InstructionNamespace,\n  TransactionNamespace,\n  AccountNamespace,\n  StateNamespace,\n  SimulateNamespace,\n} from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { decodeUtf8 } from \"../utils\";\nimport { EventParser } from \"./event\";\n\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties (internally referred to as namespaces) that\n * map one-to-one to program instructions and accounts. These namespaces\n * generally can be used as follows:\n *\n * ```javascript\n * program.<namespace>.<program-specific-field>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://project-serum.github.io/anchor/ts/#examples).\n */\nexport class Program {\n  /**\n   * Async methods to send signed transactions invoking *non*-state methods\n   * on an Anchor program.\n   *\n   * ## rpc\n   *\n   * ```javascript\n   * program.rpc.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To send a transaction invoking the `increment` method above,\n   *\n   * ```javascript\n   * const txSignature = await program.rpc.increment({\n   *   accounts: {\n   *     counter,\n   *     authority,\n   *   },\n   * });\n   * ```\n   */\n  readonly rpc: RpcNamespace;\n\n  /**\n   * Async functions to fetch deserialized program accounts from a cluster.\n   *\n   * ## account\n   *\n   * ```javascript\n   * program.account.<account>(publicKey);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `publicKey` - The [[PublicKey]] of the account.\n   *\n   * ## Example\n   *\n   * To fetch a `Counter` object from the above example,\n   *\n   * ```javascript\n   * const counter = await program.account.counter(publicKey);\n   * ```\n   */\n  readonly account: AccountNamespace;\n\n  /**\n   * Functions to build [[TransactionInstruction]] objects for program methods.\n   *\n   * ## instruction\n   *\n   * ```javascript\n   * program.instruction.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To create an instruction for the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.instruction.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly instruction: InstructionNamespace;\n\n  /**\n   * Functions to build [[Transaction]] objects.\n   *\n   * ## transaction\n   *\n   * ```javascript\n   * program.transaction.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To create an instruction for the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.transaction.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly transaction: TransactionNamespace;\n\n  /**\n   * Async functions to simulate instructions against an Anchor program,\n   * returning a list of deserialized events *and* raw program logs.\n   *\n   * One can use this to read data calculated from a program on chain, by\n   * emitting an event in the program and reading the emitted event client side\n   * via the `simulate` namespace.\n   *\n   * ## simulate\n   *\n   * ```javascript\n   * program.simulate.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To simulate the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.simulate.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly simulate: SimulateNamespace;\n\n  /**\n   * Object with state account accessors and rpcs.\n   */\n  readonly state: StateNamespace;\n\n  /**\n   * Address of the program.\n   */\n  public get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  /**\n   * IDL defining the program's interface.\n   */\n  public get idl(): Idl {\n    return this._idl;\n  }\n  private _idl: Idl;\n\n  /**\n   * Coder for serializing requests.\n   */\n  public get coder(): Coder {\n    return this._coder;\n  }\n  private _coder: Coder;\n\n  /**\n   * Wallet and network provider.\n   */\n  public get provider(): Provider {\n    return this._provider;\n  }\n  private _provider: Provider;\n\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  public constructor(idl: Idl, programId: PublicKey, provider?: Provider) {\n    // Fields.\n    this._idl = idl;\n    this._programId = programId;\n    this._provider = provider ?? getProvider();\n    this._coder = new Coder(idl);\n\n    // Dynamic namespaces.\n    const [\n      rpc,\n      instruction,\n      transaction,\n      account,\n      state,\n      simulate,\n    ] = NamespaceFactory.build(idl, this._coder, programId, this._provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.state = state;\n    this.simulate = simulate;\n  }\n\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  public static async at(programId: PublicKey, provider?: Provider) {\n    const idl = await Program.fetchIdl(programId, provider);\n    return new Program(idl, programId, provider);\n  }\n\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  public static async fetchIdl(programId: PublicKey, provider?: Provider) {\n    provider = provider ?? getProvider();\n    const address = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(address);\n    // Chop off account discriminator.\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(decodeUtf8(inflatedIdl));\n  }\n\n  /**\n   * Invokes the given callback everytime the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n  public addEventListener(\n    eventName: string,\n    callback: (event: any, slot: number) => void\n  ): number {\n    const eventParser = new EventParser(\n      this._coder,\n      this._programId,\n      this._idl\n    );\n    return this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n      eventParser.parseLogs(logs.logs, (event) => {\n        if (event.name === eventName) {\n          callback(event.data, ctx.slot);\n        }\n      });\n    });\n  }\n\n  /**\n   * Unsubscribes from the given event listener.\n   */\n  public async removeEventListener(listener: number): Promise<void> {\n    return this._provider.connection.removeOnLogsListener(listener);\n  }\n}\n","import camelCase from \"camelcase\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Program } from \"./program\";\n\nlet _populatedWorkspace = false;\n\n/**\n * The `workspace` namespace provides a convenience API to automatically\n * search for and deserialize [[Program]] objects defined by compiled IDLs\n * in an Anchor workspace.\n *\n * This API is for Node only.\n */\nconst workspace = new Proxy({} as any, {\n  get(workspaceCache: { [key: string]: Program }, programName: string) {\n    const find = require(\"find\");\n    const fs = require(\"fs\");\n    const process = require(\"process\");\n\n    if (typeof window !== \"undefined\") {\n      // Workspaces aren't available in the browser, yet.\n      return undefined;\n    }\n\n    if (!_populatedWorkspace) {\n      const path = require(\"path\");\n\n      let projectRoot = process.cwd();\n      while (!fs.existsSync(path.join(projectRoot, \"Anchor.toml\"))) {\n        const parentDir = path.dirname(projectRoot);\n        if (parentDir === projectRoot) {\n          projectRoot = undefined;\n        }\n        projectRoot = parentDir;\n      }\n\n      if (projectRoot === undefined) {\n        throw new Error(\"Could not find workspace root.\");\n      }\n\n      find\n        .fileSync(/target\\/idl\\/.*\\.json/, projectRoot)\n        .reduce((programs: any, path: string) => {\n          const idlStr = fs.readFileSync(path);\n          const idl = JSON.parse(idlStr);\n          const name = camelCase(idl.name, { pascalCase: true });\n          programs[name] = new Program(\n            idl,\n            new PublicKey(idl.metadata.address)\n          );\n          return programs;\n        }, workspaceCache);\n\n      _populatedWorkspace = true;\n    }\n\n    return workspaceCache[programName];\n  },\n});\n\nexport default workspace;\n","import BN from \"bn.js\";\nimport * as web3 from \"@solana/web3.js\";\nimport Provider, { NodeWallet as Wallet } from \"./provider\";\nimport Coder from \"./coder\";\nimport { Idl } from \"./idl\";\nimport workspace from \"./workspace\";\nimport utils from \"./utils\";\nimport { Program } from \"./program\";\nimport { ProgramAccount } from \"./program/namespace\";\nimport { Context, Accounts } from \"./program/context\";\n\nlet _provider: Provider | null = null;\n\nfunction setProvider(provider: Provider) {\n  _provider = provider;\n}\n\nfunction getProvider(): Provider {\n  if (_provider === null) {\n    return Provider.local();\n  }\n  return _provider;\n}\n\nexport {\n  workspace,\n  Program,\n  ProgramAccount,\n  Context,\n  Accounts,\n  Coder,\n  setProvider,\n  getProvider,\n  Provider,\n  BN,\n  web3,\n  Idl,\n  utils,\n  Wallet,\n};\n"],"names":["_settle","pact","state","value","v","Provider","connection","wallet","opts","this","defaultOptions","preflightCommitment","commitment","local","url","Connection","NodeWallet","env","require","ANCHOR_PROVIDER_URL","undefined","Error","options","send","tx","signers","_this2","signerKps","filter","s","signerPubkeys","publicKey","concat","map","setSigners","getRecentBlockhash","recentBlockhash","_this$connection$getR","blockhash","signTransaction","forEach","kp","partialSign","rawTx","serialize","sendAndConfirmRawTransaction","sendAll","reqs","_this4","txs","r","signAllTransactions","signedTxs","sigs","k","length","push","_push","simulate","_this6","_this5$connection$get","transaction","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","encodedTransaction","_serialize","toString","_rpcRequest","encoding","res","error","message","result","simulateTransaction","payer","Account","Buffer","from","JSON","parse","readFileSync","homedir","t","_this10","IdlError","ProgramError","code","msg","_this","stateDiscriminator","name","sha256","digest","slice","accountDiscriminator","Coder","idl","instruction","InstructionCoder","accounts","AccountsCoder","types","TypesCoder","events","EventCoder","StateCoder","sighash","nameSpace","ixName","ixLayout","parseIxLayout","encode","ix","_encode","encodeState","buffer","alloc","methodName","camelCase","len","get","data","ixLayouts","methods","m","fieldLayouts","args","arg","IdlCoder","fieldLayout","borsh","struct","instructions","Map","layouts","acc","typeDefLayout","accountLayouts","accountName","account","accountData","discriminator","decode","event","eventTypeDef","type","kind","fields","f","eventName","layout","disc","accData","field","fieldName","bool","u8","u16","u32","u64","i64","u128","i128","vecU8","str","vec","option","defined","filtered","stringify","array","arrayLen","innerLayout","typeDef","variants","variant","rustEnum","replicate","typeSize","ty","accountSize","arraySize","idlAccount","variantSizes","reduce","a","b","Math","max","snakeCase","idlAddress","programId","PublicKey","findProgramAddress","createWithSeed","_PublicKey$findProgra","IDL_ACCOUNT_LAYOUT","toInstruction","idlIx","idx","ixArg","validateAccounts","ixAccounts","translateError","idlErrors","err","components","split","errorCode","parseInt","errorMsg","parseErr","splitArgsAndCtx","inputLen","pop","InstructionNamespaceFactory","build","coder","ixArgs","ctx","validateInstruction","keys","accountsArray","remainingAccounts","__private","logAccounts","console","log","TransactionInstruction","accs","nestedAccounts","flat","pubkey","isWritable","isMut","isSigner","programStateAddress","StateFactory","provider","addr","getAccountInfo","accountInfo","expectedDiscriminator","compare","rpc","programSigner","SystemProgram","SYSVAR_RENT_PUBKEY","stateInstructionKeys","ixFn","Transaction","add","_add2","translatedErr","sub","ee","EventEmitter","then","address","listener","onAccountChange","emit","removeAccountChangeListener","TransactionFactory","RpcFactory","txFn","subscriptions","AccountFactory","accountFns","accountsNamespace","sizeOverride","size","createAccount","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","set","warn","bytes","toBase58","filters","memcmp","offset","bs58","resp","seeds","toBuffer","LOG_START_INDEX","EventParser","discriminators","e","base64","fromByteArray","parseLogs","logs","callback","logScanner","LogScanner","execution","ExecutionContext","next","handleLog","newProgram","didPop","program","handleProgramLog","handleSystemLog","startsWith","logStr","logArr","toByteArray","logStart","includes","match","exec","stack","assert","ok","l","SimulateFactory","raw","NamespaceFactory","errors","parseIdlErrors","ixItem","InstructionFactory","txItem","rpcItem","simulateItem","utils","getMultipleAccounts","publicKeys","join","executable","owner","Program","_idl","_programId","_provider","getProvider","_coder","at","fetchIdl","inflatedIdl","inflate","TextDecoder","addEventListener","eventParser","onLogs","slot","removeEventListener","removeOnLogsListener","_populatedWorkspace","workspace","Proxy","workspaceCache","programName","find","fs","process","window","path","projectRoot","cwd","existsSync","parentDir","dirname","fileSync","programs","idlStr","pascalCase","metadata"],"mappings":"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"}