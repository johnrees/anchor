{"version":3,"file":"index.modern.js","sources":["../src/provider.ts","../src/error.ts","../src/coder.ts","../src/idl.ts","../src/program/common.ts","../src/program/context.ts","../src/program/namespace/instruction.ts","../src/program/namespace/state.ts","../src/program/namespace/account.ts","../src/program/event.ts","../src/utils.ts","../src/program/index.ts","../src/program/namespace/index.ts","../src/program/namespace/transaction.ts","../src/program/namespace/rpc.ts","../src/program/namespace/simulate.ts","../src/workspace.ts","../src/index.ts"],"sourcesContent":["import {\n  Connection,\n  Account,\n  PublicKey,\n  Transaction,\n  TransactionSignature,\n  ConfirmOptions,\n  sendAndConfirmRawTransaction,\n  RpcResponseAndContext,\n  SimulatedTransactionResponse,\n  Commitment,\n} from \"@solana/web3.js\";\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nexport default class Provider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(\n    readonly connection: Connection,\n    readonly wallet: Wallet,\n    readonly opts: ConfirmOptions\n  ) {}\n\n  static defaultOptions(): ConfirmOptions {\n    return {\n      preflightCommitment: \"recent\",\n      commitment: \"recent\",\n    };\n  }\n\n  /**\n   * Returns a `Provider` with a wallet read from the local filesystem.\n   *\n   * @param url  The network cluster url.\n   * @param opts The default transaction confirmation options.\n   *\n   * (This api is for Node only.)\n   */\n  static local(url?: string, opts?: ConfirmOptions): Provider {\n    opts = opts || Provider.defaultOptions();\n    const connection = new Connection(\n      url || \"http://localhost:8899\",\n      opts.preflightCommitment\n    );\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, opts);\n  }\n\n  /**\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` envirnment\n   * variable\n   *\n   * (This api is for Node only.)\n   */\n  static env(): Provider {\n    const process = require(\"process\");\n    const url = process.env.ANCHOR_PROVIDER_URL;\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n    const options = Provider.defaultOptions();\n    const connection = new Connection(url, options.commitment);\n    const wallet = NodeWallet.local();\n\n    return new Provider(connection, wallet, options);\n  }\n\n  /**\n   * Sends the given transaction, ppaid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async send(\n    tx: Transaction,\n    signers?: Array<Account | undefined>,\n    opts?: ConfirmOptions\n  ): Promise<TransactionSignature> {\n    if (signers === undefined) {\n      signers = [];\n    }\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    const signerKps = signers.filter((s) => s !== undefined) as Array<Account>;\n    const signerPubkeys = [this.wallet.publicKey].concat(\n      signerKps.map((s) => s.publicKey)\n    );\n\n    tx.setSigners(...signerPubkeys);\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(opts.preflightCommitment)\n    ).blockhash;\n\n    await this.wallet.signTransaction(tx);\n    signerKps.forEach((kp) => {\n      tx.partialSign(kp);\n    });\n\n    const rawTx = tx.serialize();\n\n    const txId = await sendAndConfirmRawTransaction(\n      this.connection,\n      rawTx,\n      opts\n    );\n\n    return txId;\n  }\n\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n  async sendAll(\n    reqs: Array<SendTxRequest>,\n    opts?: ConfirmOptions\n  ): Promise<Array<TransactionSignature>> {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    const blockhash = await this.connection.getRecentBlockhash(\n      opts.preflightCommitment\n    );\n\n    let txs = reqs.map((r) => {\n      let tx = r.tx;\n      let signers = r.signers;\n\n      if (signers === undefined) {\n        signers = [];\n      }\n\n      const signerKps = signers.filter(\n        (s) => s !== undefined\n      ) as Array<Account>;\n      const signerPubkeys = [this.wallet.publicKey].concat(\n        signerKps.map((s) => s.publicKey)\n      );\n\n      tx.setSigners(...signerPubkeys);\n      tx.recentBlockhash = blockhash.blockhash;\n      signerKps.forEach((kp) => {\n        tx.partialSign(kp);\n      });\n\n      return tx;\n    });\n\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n\n    const sigs = [];\n\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(\n        await sendAndConfirmRawTransaction(this.connection, rawTx, opts)\n      );\n    }\n\n    return sigs;\n  }\n\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async simulate(\n    tx: Transaction,\n    signers?: Array<Account | undefined>,\n    opts?: ConfirmOptions\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (signers === undefined) {\n      signers = [];\n    }\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    const signerKps = signers.filter((s) => s !== undefined) as Array<Account>;\n    const signerPubkeys = [this.wallet.publicKey].concat(\n      signerKps.map((s) => s.publicKey)\n    );\n\n    tx.setSigners(...signerPubkeys);\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(opts.preflightCommitment)\n    ).blockhash;\n\n    await this.wallet.signTransaction(tx);\n    signerKps.forEach((kp) => {\n      tx.partialSign(kp);\n    });\n    return await simulateTransaction(this.connection, tx, opts.commitment);\n  }\n}\n\nexport type SendTxRequest = {\n  tx: Transaction;\n  signers: Array<Account | undefined>;\n};\n\n/**\n * Wallet interface for objects that can be used to sign provider transactions.\n */\nexport interface Wallet {\n  signTransaction(tx: Transaction): Promise<Transaction>;\n  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;\n  publicKey: PublicKey;\n}\n\n/**\n * Node only wallet.\n */\nexport class NodeWallet implements Wallet {\n  constructor(readonly payer: Account) {}\n\n  static local(): NodeWallet {\n    const payer = new Account(\n      Buffer.from(\n        JSON.parse(\n          require(\"fs\").readFileSync(\n            require(\"os\").homedir() + \"/.config/solana/id.json\",\n            {\n              encoding: \"utf-8\",\n            }\n          )\n        )\n      )\n    );\n    return new NodeWallet(payer);\n  }\n\n  async signTransaction(tx: Transaction): Promise<Transaction> {\n    tx.partialSign(this.payer);\n    return tx;\n  }\n\n  async signAllTransactions(txs: Transaction[]): Promise<Transaction[]> {\n    return txs.map((t) => {\n      t.partialSign(this.payer);\n      return t;\n    });\n  }\n\n  get publicKey(): PublicKey {\n    return this.payer.publicKey;\n  }\n}\n\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n","export class IdlError extends Error {}\n\n// An error from a user defined program.\nexport class ProgramError extends Error {\n  constructor(readonly code: number, readonly msg: string, ...params: any[]) {\n    super(...params);\n  }\n\n  public toString(): string {\n    return this.msg;\n  }\n}\n","import camelCase from \"camelcase\";\nimport { snakeCase } from \"snake-case\";\nimport { Layout } from \"buffer-layout\";\nimport * as sha256 from \"js-sha256\";\nimport * as borsh from \"@project-serum/borsh\";\nimport {\n  Idl,\n  IdlField,\n  IdlTypeDef,\n  IdlEnumVariant,\n  IdlType,\n  IdlStateMethod,\n} from \"./idl\";\nimport { IdlError } from \"./error\";\n\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n\n/**\n * Coder provides a facade for encoding and decoding all IDL related objects.\n */\nexport default class Coder {\n  /**\n   * Instruction coder.\n   */\n  readonly instruction: InstructionCoder;\n\n  /**\n   * Account coder.\n   */\n  readonly accounts: AccountsCoder;\n\n  /**\n   * Types coder.\n   */\n  readonly types: TypesCoder;\n\n  /**\n   * Coder for state structs.\n   */\n  readonly state: StateCoder;\n\n  /**\n   * Coder for events.\n   */\n  readonly events: EventCoder;\n\n  constructor(idl: Idl) {\n    this.instruction = new InstructionCoder(idl);\n    this.accounts = new AccountsCoder(idl);\n    this.types = new TypesCoder(idl);\n    this.events = new EventCoder(idl);\n    if (idl.state) {\n      this.state = new StateCoder(idl);\n    }\n  }\n\n  public sighash(nameSpace: string, ixName: string): Buffer {\n    return sighash(nameSpace, ixName);\n  }\n}\n\n/**\n * Encodes and decodes program instructions.\n */\nclass InstructionCoder {\n  /**\n   * Instruction args layout. Maps namespaced method\n   */\n  private ixLayout: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n  }\n\n  /**\n   * Encodes a program instruction.\n   */\n  public encode(ixName: string, ix: any) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n\n  /**\n   * Encodes a program state instruction.\n   */\n  public encodeState(ixName: string, ix: any) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  private _encode(nameSpace: string, ixName: string, ix: any): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = camelCase(ixName);\n    const len = this.ixLayout.get(methodName).encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  private static parseIxLayout(idl: Idl): Map<string, Layout> {\n    const stateMethods = idl.state ? idl.state.methods : [];\n\n    const ixLayouts = stateMethods\n      .map((m: IdlStateMethod) => {\n        let fieldLayouts = m.args.map((arg: IdlField) => {\n          return IdlCoder.fieldLayout(arg, idl.types);\n        });\n        const name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })\n      .concat(\n        idl.instructions.map((ix) => {\n          let fieldLayouts = ix.args.map((arg: IdlField) =>\n            IdlCoder.fieldLayout(arg, idl.types)\n          );\n          const name = camelCase(ix.name);\n          return [name, borsh.struct(fieldLayouts, name)];\n        })\n      );\n    // @ts-ignore\n    return new Map(ixLayouts);\n  }\n}\n\n/**\n * Encodes and decodes account objects.\n */\nclass AccountsCoder {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private accountLayouts: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts: [string, Layout][] = idl.accounts.map((acc) => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n\n    this.accountLayouts = new Map(layouts);\n  }\n\n  public async encode<T = any>(\n    accountName: string,\n    account: T\n  ): Promise<Buffer> {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = await accountDiscriminator(accountName);\n    return Buffer.concat([discriminator, accountData]);\n  }\n\n  public decode<T = any>(accountName: string, ix: Buffer): T {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(8);\n    const layout = this.accountLayouts.get(accountName);\n    return layout.decode(data);\n  }\n}\n\n/**\n * Encodes and decodes user defined types.\n */\nclass TypesCoder {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private layouts: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.types === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n    const layouts = idl.types.map((acc) => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n\n    // @ts-ignore\n    this.layouts = new Map(layouts);\n  }\n\n  public encode<T = any>(accountName: string, account: T): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.layouts.get(accountName);\n    const len = layout.encode(account, buffer);\n    return buffer.slice(0, len);\n  }\n\n  public decode<T = any>(accountName: string, ix: Buffer): T {\n    const layout = this.layouts.get(accountName);\n    return layout.decode(ix);\n  }\n}\n\nclass EventCoder {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private layouts: Map<string, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.events === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n    const layouts = idl.events.map((event) => {\n      let eventTypeDef: IdlTypeDef = {\n        name: event.name,\n        type: {\n          kind: \"struct\",\n          fields: event.fields.map((f) => {\n            return { name: f.name, type: f.type };\n          }),\n        },\n      };\n      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n    });\n    // @ts-ignore\n    this.layouts = new Map(layouts);\n  }\n\n  public encode<T = any>(eventName: string, account: T): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.layouts.get(eventName);\n    const len = layout.encode(account, buffer);\n    return buffer.slice(0, len);\n  }\n\n  public decode<T = any>(eventName: string, ix: Buffer): T {\n    const layout = this.layouts.get(eventName);\n    return layout.decode(ix);\n  }\n}\n\nclass StateCoder {\n  private layout: Layout;\n\n  public constructor(idl: Idl) {\n    if (idl.state === undefined) {\n      throw new Error(\"Idl state not defined.\");\n    }\n    this.layout = IdlCoder.typeDefLayout(idl.state.struct, idl.types);\n  }\n\n  public async encode<T = any>(name: string, account: T): Promise<Buffer> {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const len = this.layout.encode(account, buffer);\n\n    const disc = await stateDiscriminator(name);\n    const accData = buffer.slice(0, len);\n\n    return Buffer.concat([disc, accData]);\n  }\n\n  public decode<T = any>(ix: Buffer): T {\n    // Chop off discriminator.\n    const data = ix.slice(8);\n    return this.layout.decode(data);\n  }\n}\n\nclass IdlCoder {\n  public static fieldLayout(field: IdlField, types?: IdlTypeDef[]): Layout {\n    const fieldName =\n      field.name !== undefined ? camelCase(field.name) : undefined;\n    switch (field.type) {\n      case \"bool\": {\n        return borsh.bool(fieldName);\n      }\n      case \"u8\": {\n        return borsh.u8(fieldName);\n      }\n      case \"u16\": {\n        return borsh.u16(fieldName);\n      }\n      case \"u32\": {\n        return borsh.u32(fieldName);\n      }\n      case \"u64\": {\n        return borsh.u64(fieldName);\n      }\n      case \"i64\": {\n        return borsh.i64(fieldName);\n      }\n      case \"u128\": {\n        return borsh.u128(fieldName);\n      }\n      case \"i128\": {\n        return borsh.i128(fieldName);\n      }\n      case \"bytes\": {\n        return borsh.vecU8(fieldName);\n      }\n      case \"string\": {\n        return borsh.str(fieldName);\n      }\n      case \"publicKey\": {\n        return borsh.publicKey(fieldName);\n      }\n      // TODO: all the other types that need to be exported by the borsh package.\n      default: {\n        // @ts-ignore\n        if (field.type.vec) {\n          return borsh.vec(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                // @ts-ignore\n                type: field.type.vec,\n              },\n              types\n            ),\n            fieldName\n          );\n          // @ts-ignore\n        } else if (field.type.option) {\n          return borsh.option(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                // @ts-ignore\n                type: field.type.option,\n              },\n              types\n            ),\n            fieldName\n          );\n          // @ts-ignore\n        } else if (field.type.defined) {\n          // User defined type.\n          if (types === undefined) {\n            throw new IdlError(\"User defined types not provided\");\n          }\n          // @ts-ignore\n          const filtered = types.filter((t) => t.name === field.type.defined);\n          if (filtered.length !== 1) {\n            throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n          }\n          return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n          // @ts-ignore\n        } else if (field.type.array) {\n          // @ts-ignore\n          let arrayTy = field.type.array[0];\n          // @ts-ignore\n          let arrayLen = field.type.array[1];\n          let innerLayout = IdlCoder.fieldLayout(\n            {\n              name: undefined,\n              type: arrayTy,\n            },\n            types\n          );\n          return borsh.array(innerLayout, arrayLen, fieldName);\n        } else {\n          throw new Error(`Not yet implemented: ${field}`);\n        }\n      }\n    }\n  }\n\n  public static typeDefLayout(\n    typeDef: IdlTypeDef,\n    types: IdlTypeDef[],\n    name?: string\n  ): Layout {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map((field) => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map((variant: IdlEnumVariant) => {\n        const name = camelCase(variant.name);\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        }\n        // @ts-ignore\n        const fieldLayouts = variant.fields.map((f: IdlField | IdlType) => {\n          // @ts-ignore\n          if (f.name === undefined) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          }\n          // @ts-ignore\n          return IdlCoder.fieldLayout(f, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n}\n\n// Calculates unique 8 byte discriminator prepended to all anchor accounts.\nexport async function accountDiscriminator(name: string): Promise<Buffer> {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\n\n// Calculates unique 8 byte discriminator prepended to all anchor state accounts.\nexport async function stateDiscriminator(name: string): Promise<Buffer> {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\n\nexport function eventDiscriminator(name: string): Buffer {\n  // @ts-ignore\n  return Buffer.from(sha256.digest(`event:${name}`)).slice(0, 8);\n}\n\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl: Idl, ty: IdlType): number {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      }\n      // @ts-ignore\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      }\n      // @ts-ignore\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        const filtered = idl.types.filter((t) => t.name === ty.defined);\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n        let typeDef = filtered[0];\n\n        return accountSize(idl, typeDef);\n      }\n      // @ts-ignore\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        let arrayTy = ty.array[0];\n        // @ts-ignore\n        let arraySize = ty.array[1];\n        // @ts-ignore\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n}\n\nexport function accountSize(\n  idl: Idl,\n  idlAccount: IdlTypeDef\n): number | undefined {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(\n      (variant: IdlEnumVariant) => {\n        if (variant.fields === undefined) {\n          return 0;\n        }\n        // @ts-ignore\n        return (\n          variant.fields\n            // @ts-ignore\n            .map((f: IdlField | IdlType) => {\n              // @ts-ignore\n              if (f.name === undefined) {\n                throw new Error(\"Tuple enum variants not yet implemented.\");\n              }\n              // @ts-ignore\n              return typeSize(idl, f.type);\n            })\n            .reduce((a: number, b: number) => a + b)\n        );\n      }\n    );\n    return Math.max(...variantSizes) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields\n    .map((f) => typeSize(idl, f.type))\n    .reduce((a, b) => a + b);\n}\n\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace: string, ixName: string): Buffer {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}::${name}`;\n  // @ts-ignore\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n\nexport type Idl = {\n  version: string;\n  name: string;\n  instructions: IdlInstruction[];\n  state?: IdlState;\n  accounts?: IdlTypeDef[];\n  types?: IdlTypeDef[];\n  events?: IdlEvent[];\n  errors?: IdlErrorCode[];\n};\n\nexport type IdlEvent = {\n  name: string;\n  fields: IdlEventField[];\n};\n\nexport type IdlEventField = {\n  name: string;\n  type: IdlType;\n  index: boolean;\n};\n\nexport type IdlInstruction = {\n  name: string;\n  accounts: IdlAccountItem[];\n  args: IdlField[];\n};\n\n// IdlStateMethods are similar to instructions, except they only allow\n// for a single account, the state account.\nexport type IdlState = {\n  struct: IdlTypeDef;\n  methods: IdlStateMethod[];\n};\n\nexport type IdlStateMethod = IdlInstruction;\n\nexport type IdlAccountItem = IdlAccount | IdlAccounts;\n\nexport type IdlAccount = {\n  name: string;\n  isMut: boolean;\n  isSigner: boolean;\n};\n\n// A nested/recursive version of IdlAccount.\nexport type IdlAccounts = {\n  name: string;\n  accounts: IdlAccountItem[];\n};\n\nexport type IdlField = {\n  name: string;\n  type: IdlType;\n};\n\nexport type IdlTypeDef = {\n  name: string;\n  type: IdlTypeDefTy;\n};\n\ntype IdlTypeDefTy = {\n  kind: \"struct\" | \"enum\";\n  fields?: IdlTypeDefStruct;\n  variants?: IdlEnumVariant[];\n};\n\ntype IdlTypeDefStruct = Array<IdlField>;\n\nexport type IdlType =\n  | \"bool\"\n  | \"u8\"\n  | \"i8\"\n  | \"u16\"\n  | \"i16\"\n  | \"u32\"\n  | \"i32\"\n  | \"u64\"\n  | \"i64\"\n  | \"bytes\"\n  | \"string\"\n  | \"publicKey\"\n  | IdlTypeVec\n  | IdlTypeOption\n  | IdlTypeDefined;\n\nexport type IdlTypeVec = {\n  vec: IdlType;\n};\n\nexport type IdlTypeOption = {\n  option: IdlType;\n};\n\n// User defined type.\nexport type IdlTypeDefined = {\n  defined: string;\n};\n\nexport type IdlEnumVariant = {\n  name: string;\n  fields?: IdlEnumFields;\n};\n\ntype IdlEnumFields = IdlEnumFieldsNamed | IdlEnumFieldsTuple;\n\ntype IdlEnumFieldsNamed = IdlField[];\n\ntype IdlEnumFieldsTuple = IdlType[];\n\ntype IdlErrorCode = {\n  code: number;\n  name: string;\n  msg?: string;\n};\n\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId: PublicKey): Promise<PublicKey> {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n\n// Seed for generating the idlAddress.\nexport function seed(): string {\n  return \"anchor:idl\";\n}\n\n// The on-chain account of the IDL.\nexport interface IdlProgramAccount {\n  authority: PublicKey;\n  data: Buffer;\n}\n\nconst IDL_ACCOUNT_LAYOUT: borsh.Layout<IdlProgramAccount> = borsh.struct([\n  borsh.publicKey(\"authority\"),\n  borsh.vecU8(\"data\"),\n]);\n\nexport function decodeIdlAccount(data: Buffer): IdlProgramAccount {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n\nexport function encodeIdlAccount(acc: IdlProgramAccount): Buffer {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\n","import EventEmitter from \"eventemitter3\";\nimport { Idl, IdlInstruction, IdlAccountItem, IdlStateMethod } from \"../idl\";\nimport { ProgramError } from \"../error\";\nimport { Accounts } from \"./context\";\n\nexport type Subscription = {\n  listener: number;\n  ee: EventEmitter;\n};\n\nexport function parseIdlErrors(idl: Idl): Map<number, string> {\n  const errors = new Map();\n  if (idl.errors) {\n    idl.errors.forEach((e) => {\n      let msg = e.msg ?? e.name;\n      errors.set(e.code, msg);\n    });\n  }\n  return errors;\n}\n\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nexport function toInstruction(\n  idlIx: IdlInstruction | IdlStateMethod,\n  ...args: any[]\n) {\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n  const ix: { [key: string]: any } = {};\n  let idx = 0;\n  idlIx.args.forEach((ixArg) => {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n\n  return ix;\n}\n\n// Throws error if any account required for the `ix` is not given.\nexport function validateAccounts(\n  ixAccounts: IdlAccountItem[],\n  accounts: Accounts\n) {\n  ixAccounts.forEach((acc) => {\n    // @ts-ignore\n    if (acc.accounts !== undefined) {\n      // @ts-ignore\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n      }\n    }\n  });\n}\n\nexport function translateError(\n  idlErrors: Map<number, string>,\n  err: any\n): Error | null {\n  // TODO: don't rely on the error string. web3.js should preserve the error\n  //       code information instead of giving us an untyped string.\n  let components = err.toString().split(\"custom program error: \");\n  if (components.length === 2) {\n    try {\n      const errorCode = parseInt(components[1]);\n      let errorMsg = idlErrors.get(errorCode);\n      if (errorMsg === undefined) {\n        // Unexpected error code so just throw the untranslated error.\n        return null;\n      }\n      return new ProgramError(errorCode, errorMsg);\n    } catch (parseErr) {\n      // Unable to parse the error. Just return the untranslated error.\n      return null;\n    }\n  }\n}\n","import {\n  Account,\n  AccountMeta,\n  PublicKey,\n  ConfirmOptions,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { IdlInstruction } from \"../idl\";\n\n/**\n * Context provides all non-argument inputs for generating Anchor transactions.\n */\nexport type Context = {\n  /**\n   * Accounts used in the instruction context.\n   */\n  accounts?: Accounts;\n\n  /**\n   * All accounts to pass into an instruction *after* the main `accounts`.\n   * This can be used for optional or otherwise unknown accounts.\n   */\n  remainingAccounts?: AccountMeta[];\n\n  /**\n   * Accounts that must sign a given transaction.\n   */\n  signers?: Array<Account>;\n\n  /**\n   * Instructions to run *before* a given method. Often this is used, for\n   * example to create accounts prior to executing a method.\n   */\n  instructions?: TransactionInstruction[];\n\n  /**\n   * Commitment parameters to use for a transaction.\n   */\n  options?: ConfirmOptions;\n\n  /**\n   * @hidden\n   *\n   * Private namespace for development.\n   */\n  __private?: { logAccounts: boolean };\n};\n\n/**\n * A set of accounts mapping one-to-one to the program's accounts struct, i.e.,\n * the type deriving `#[derive(Accounts)]`.\n *\n * The name of each field should match the name for that account in the IDL.\n *\n * If multiple accounts are nested in the rust program, then they should be\n * nested here.\n */\nexport type Accounts = {\n  [key: string]: PublicKey | Accounts;\n};\n\nexport function splitArgsAndCtx(\n  idlIx: IdlInstruction,\n  args: any[]\n): [any[], Context] {\n  let options = {};\n\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(\"provided too many arguments ${args}\");\n    }\n    options = args.pop();\n  }\n\n  return [args, options];\n}\n","import { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlAccount, IdlInstruction, IdlAccountItem } from \"../../idl\";\nimport { IdlError } from \"../../error\";\nimport Coder from \"../../coder\";\nimport { toInstruction, validateAccounts } from \"../common\";\nimport { Accounts, splitArgsAndCtx } from \"../context\";\n\n/**\n * Dynamically generated instruction namespace.\n */\nexport interface InstructionNamespace {\n  [key: string]: IxFn;\n}\n\n/**\n * Ix is a function to create a `TransactionInstruction` generated from an IDL.\n */\nexport type IxFn = IxProps & ((...args: any[]) => any);\ntype IxProps = {\n  accounts: (ctx: Accounts) => any;\n};\n\nexport default class InstructionNamespaceFactory {\n  // Builds the instuction namespace.\n  public static build(\n    idlIx: IdlInstruction,\n    coder: Coder,\n    programId: PublicKey\n  ): IxFn {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = (...args: any[]): TransactionInstruction => {\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n\n      const keys = InstructionNamespaceFactory.accountsArray(\n        ctx.accounts,\n        idlIx.accounts\n      );\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (ctx.__private && ctx.__private.logAccounts) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: coder.instruction.encode(\n          idlIx.name,\n          toInstruction(idlIx, ...ixArgs)\n        ),\n      });\n    };\n\n    // Utility fn for ordering the accounts for this instruction.\n    ix[\"accounts\"] = (accs: Accounts) => {\n      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n    };\n\n    return ix;\n  }\n\n  public static accountsArray(ctx: Accounts, accounts: IdlAccountItem[]): any {\n    return accounts\n      .map((acc: IdlAccountItem) => {\n        // Nested accounts.\n        // @ts-ignore\n        const nestedAccounts: IdlAccountItem[] | undefined = acc.accounts;\n        if (nestedAccounts !== undefined) {\n          const rpcAccs = ctx[acc.name] as Accounts;\n          return InstructionNamespaceFactory.accountsArray(\n            rpcAccs,\n            nestedAccounts\n          ).flat();\n        } else {\n          const account: IdlAccount = acc as IdlAccount;\n          return {\n            pubkey: ctx[acc.name],\n            isWritable: account.isMut,\n            isSigner: account.isSigner,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix: IdlInstruction, ...args: any[]) {\n  // todo\n}\n","import EventEmitter from \"eventemitter3\";\nimport {\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionSignature,\n  TransactionInstruction,\n  SYSVAR_RENT_PUBKEY,\n  Commitment,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { Idl, IdlStateMethod } from \"../../idl\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { RpcNamespace, InstructionNamespace } from \"./\";\nimport {\n  Subscription,\n  translateError,\n  toInstruction,\n  validateAccounts,\n} from \"../common\";\nimport { Accounts, splitArgsAndCtx } from \"../context\";\nimport InstructionNamespaceFactory from \"./instruction\";\n\nexport type StateNamespace = () =>\n  | Promise<any>\n  | {\n      address: () => Promise<PublicKey>;\n      rpc: RpcNamespace;\n      instruction: InstructionNamespace;\n      subscribe: (address: PublicKey, commitment?: Commitment) => EventEmitter;\n      unsubscribe: (address: PublicKey) => void;\n    };\n\nexport default class StateFactory {\n  // Builds the state namespace.\n  public static build(\n    idl: Idl,\n    coder: Coder,\n    programId: PublicKey,\n    idlErrors: Map<number, string>,\n    provider: Provider\n  ): StateNamespace | undefined {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n\n    // Fetches the state object from the blockchain.\n    const state = async (): Promise<any> => {\n      const addr = await programStateAddress(programId);\n      const accountInfo = await provider.connection.getAccountInfo(addr);\n      if (accountInfo === null) {\n        throw new Error(`Account does not exist ${addr.toString()}`);\n      }\n      // Assert the account discriminator is correct.\n      const expectedDiscriminator = await stateDiscriminator(\n        idl.state.struct.name\n      );\n      if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n        throw new Error(\"Invalid account discriminator\");\n      }\n      return coder.state.decode(accountInfo.data);\n    };\n\n    // Namespace with all rpc functions.\n    const rpc: RpcNamespace = {};\n    const ix: InstructionNamespace = {};\n\n    idl.state.methods.forEach((m: IdlStateMethod) => {\n      const accounts = async (accounts: Accounts): Promise<any> => {\n        const keys = await stateInstructionKeys(\n          programId,\n          provider,\n          m,\n          accounts\n        );\n        return keys.concat(\n          InstructionNamespaceFactory.accountsArray(accounts, m.accounts)\n        );\n      };\n      const ixFn = async (...args: any[]): Promise<TransactionInstruction> => {\n        const [ixArgs, ctx] = splitArgsAndCtx(m, [...args]);\n        return new TransactionInstruction({\n          keys: await accounts(ctx.accounts),\n          programId,\n          data: coder.instruction.encodeState(\n            m.name,\n            toInstruction(m, ...ixArgs)\n          ),\n        });\n      };\n      ixFn[\"accounts\"] = accounts;\n      ix[m.name] = ixFn;\n\n      rpc[m.name] = async (...args: any[]): Promise<TransactionSignature> => {\n        const [_, ctx] = splitArgsAndCtx(m, [...args]);\n        const tx = new Transaction();\n        if (ctx.instructions !== undefined) {\n          tx.add(...ctx.instructions);\n        }\n        tx.add(await ix[m.name](...args));\n        try {\n          const txSig = await provider.send(tx, ctx.signers, ctx.options);\n          return txSig;\n        } catch (err) {\n          let translatedErr = translateError(idlErrors, err);\n          if (translatedErr === null) {\n            throw err;\n          }\n          throw translatedErr;\n        }\n      };\n    });\n\n    state[\"rpc\"] = rpc;\n    state[\"instruction\"] = ix;\n    // Calculates the address of the program's global state object account.\n    state[\"address\"] = async (): Promise<PublicKey> =>\n      programStateAddress(programId);\n\n    // Subscription singleton.\n    let sub: null | Subscription = null;\n\n    // Subscribe to account changes.\n    state[\"subscribe\"] = (commitment?: Commitment): EventEmitter => {\n      if (sub !== null) {\n        return sub.ee;\n      }\n      const ee = new EventEmitter();\n\n      state[\"address\"]().then((address) => {\n        const listener = provider.connection.onAccountChange(\n          address,\n          (acc) => {\n            const account = coder.state.decode(acc.data);\n            ee.emit(\"change\", account);\n          },\n          commitment\n        );\n\n        sub = {\n          ee,\n          listener,\n        };\n      });\n\n      return ee;\n    };\n\n    // Unsubscribe from account changes.\n    state[\"unsubscribe\"] = () => {\n      if (sub !== null) {\n        provider.connection\n          .removeAccountChangeListener(sub.listener)\n          .then(async () => {\n            sub = null;\n          })\n          .catch(console.error);\n      }\n    };\n\n    return state;\n  }\n}\n\n// Calculates the deterministic address of the program's \"state\" account.\nasync function programStateAddress(programId: PublicKey): Promise<PublicKey> {\n  let [registrySigner, _nonce] = await PublicKey.findProgramAddress(\n    [],\n    programId\n  );\n  return PublicKey.createWithSeed(registrySigner, \"unversioned\", programId);\n}\n\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nasync function stateInstructionKeys(\n  programId: PublicKey,\n  provider: Provider,\n  m: IdlStateMethod,\n  accounts: Accounts\n) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner, _nonce] = await PublicKey.findProgramAddress(\n      [],\n      programId\n    );\n    return [\n      {\n        pubkey: provider.wallet.publicKey,\n        isWritable: false,\n        isSigner: true,\n      },\n      {\n        pubkey: await programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n      { pubkey: programSigner, isWritable: false, isSigner: false },\n      {\n        pubkey: SystemProgram.programId,\n        isWritable: false,\n        isSigner: false,\n      },\n\n      { pubkey: programId, isWritable: false, isSigner: false },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isWritable: false,\n        isSigner: false,\n      },\n    ];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [\n      {\n        pubkey: await programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n    ];\n  }\n}\n","import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport {\n  Account,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n  Commitment,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { Idl } from \"../../idl\";\nimport Coder, {\n  ACCOUNT_DISCRIMINATOR_SIZE,\n  accountDiscriminator,\n  accountSize,\n} from \"../../coder\";\nimport { Subscription } from \"../common\";\n\n/**\n * Accounts is a dynamically generated object to fetch any given account\n * of a program.\n */\nexport interface AccountNamespace {\n  [key: string]: AccountFn;\n}\n\n/**\n * Account is a function returning a deserialized account, given an address.\n */\nexport type AccountFn<T = any> = AccountProps & ((address: PublicKey) => T);\n\n/**\n * Non function properties on the acccount namespace.\n */\ntype AccountProps = {\n  size: number;\n  all: (filter?: Buffer) => Promise<ProgramAccount<any>[]>;\n  subscribe: (address: PublicKey, commitment?: Commitment) => EventEmitter;\n  unsubscribe: (address: PublicKey) => void;\n  createInstruction: (account: Account) => Promise<TransactionInstruction>;\n  associated: (...args: PublicKey[]) => Promise<any>;\n  associatedAddress: (...args: PublicKey[]) => Promise<PublicKey>;\n};\n\n/**\n * @hidden\n *\n * Deserialized account owned by a program.\n */\nexport type ProgramAccount<T = any> = {\n  publicKey: PublicKey;\n  account: T;\n};\n\n// Tracks all subscriptions.\nconst subscriptions: Map<string, Subscription> = new Map();\n\nexport default class AccountFactory {\n  // Returns the generated accounts namespace.\n  public static build(\n    idl: Idl,\n    coder: Coder,\n    programId: PublicKey,\n    provider: Provider\n  ): AccountNamespace {\n    const accountFns: AccountNamespace = {};\n\n    idl.accounts.forEach((idlAccount) => {\n      const name = camelCase(idlAccount.name);\n\n      // Fetches the decoded account from the network.\n      const accountsNamespace = async (address: PublicKey): Promise<any> => {\n        const accountInfo = await provider.connection.getAccountInfo(address);\n        if (accountInfo === null) {\n          throw new Error(`Account does not exist ${address.toString()}`);\n        }\n\n        // Assert the account discriminator is correct.\n        const discriminator = await accountDiscriminator(idlAccount.name);\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n          throw new Error(\"Invalid account discriminator\");\n        }\n\n        return coder.accounts.decode(idlAccount.name, accountInfo.data);\n      };\n\n      // Returns the size of the account.\n      // @ts-ignore\n      accountsNamespace[\"size\"] =\n        ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n\n      // Returns an instruction for creating this account.\n      // @ts-ignore\n      accountsNamespace[\"createInstruction\"] = async (\n        account: Account,\n        sizeOverride?: number\n      ): Promise<TransactionInstruction> => {\n        // @ts-ignore\n        const size = accountsNamespace[\"size\"];\n\n        return SystemProgram.createAccount({\n          fromPubkey: provider.wallet.publicKey,\n          newAccountPubkey: account.publicKey,\n          space: sizeOverride ?? size,\n          lamports: await provider.connection.getMinimumBalanceForRentExemption(\n            sizeOverride ?? size\n          ),\n          programId,\n        });\n      };\n\n      // Subscribes to all changes to this account.\n      // @ts-ignore\n      accountsNamespace[\"subscribe\"] = (\n        address: PublicKey,\n        commitment?: Commitment\n      ): EventEmitter => {\n        if (subscriptions.get(address.toString())) {\n          return subscriptions.get(address.toString()).ee;\n        }\n        const ee = new EventEmitter();\n\n        const listener = provider.connection.onAccountChange(\n          address,\n          (acc) => {\n            const account = coder.accounts.decode(idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n          },\n          commitment\n        );\n\n        subscriptions.set(address.toString(), {\n          ee,\n          listener,\n        });\n\n        return ee;\n      };\n\n      // Unsubscribes to account changes.\n      // @ts-ignore\n      accountsNamespace[\"unsubscribe\"] = (address: PublicKey) => {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n          console.warn(\"Address is not subscribed\");\n          return;\n        }\n        if (subscriptions) {\n          provider.connection\n            .removeAccountChangeListener(sub.listener)\n            .then(() => {\n              subscriptions.delete(address.toString());\n            })\n            .catch(console.error);\n        }\n      };\n\n      // Returns all instances of this account type for the program.\n      // @ts-ignore\n      accountsNamespace[\"all\"] = async (\n        filter?: Buffer\n      ): Promise<ProgramAccount<any>[]> => {\n        let bytes = await accountDiscriminator(idlAccount.name);\n        if (filter !== undefined) {\n          bytes = Buffer.concat([bytes, filter]);\n        }\n        // @ts-ignore\n        let resp = await provider.connection._rpcRequest(\"getProgramAccounts\", [\n          programId.toBase58(),\n          {\n            commitment: provider.connection.commitment,\n            filters: [\n              {\n                memcmp: {\n                  offset: 0,\n                  bytes: bs58.encode(bytes),\n                },\n              },\n            ],\n          },\n        ]);\n        if (resp.error) {\n          console.error(resp);\n          throw new Error(\"Failed to get accounts\");\n        }\n        return (\n          resp.result\n            // @ts-ignore\n            .map(({ pubkey, account: { data } }) => {\n              data = bs58.decode(data);\n              return {\n                publicKey: new PublicKey(pubkey),\n                account: coder.accounts.decode(idlAccount.name, data),\n              };\n            })\n        );\n      };\n\n      // Function returning the associated address. Args are keys to associate.\n      // Order matters.\n      accountsNamespace[\"associatedAddress\"] = async (\n        ...args: PublicKey[]\n      ): Promise<PublicKey> => {\n        let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n        args.forEach((arg) => {\n          seeds.push(arg.toBuffer());\n        });\n        const [assoc] = await PublicKey.findProgramAddress(seeds, programId);\n        return assoc;\n      };\n\n      // Function returning the associated account. Args are keys to associate.\n      // Order matters.\n      accountsNamespace[\"associated\"] = async (\n        ...args: PublicKey[]\n      ): Promise<any> => {\n        const addr = await accountsNamespace[\"associatedAddress\"](...args);\n        return await accountsNamespace(addr);\n      };\n\n      accountFns[name] = accountsNamespace;\n    });\n\n    return accountFns;\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport * as base64 from \"base64-js\";\nimport * as assert from \"assert\";\nimport Coder, { eventDiscriminator } from \"../coder\";\nimport { Idl } from \"../idl\";\n\nconst LOG_START_INDEX = \"Program log: \".length;\n\n// Deserialized event.\nexport type Event = {\n  name: string;\n  data: Object;\n};\n\nexport class EventParser {\n  private coder: Coder;\n  private programId: PublicKey;\n  // Maps base64 encoded event discriminator to event name.\n  private discriminators: Map<string, string>;\n\n  constructor(coder: Coder, programId: PublicKey, idl: Idl) {\n    this.coder = coder;\n    this.programId = programId;\n    this.discriminators = new Map<string, string>(\n      idl.events === undefined\n        ? []\n        : idl.events.map((e) => [\n            base64.fromByteArray(eventDiscriminator(e.name)),\n            e.name,\n          ])\n    );\n  }\n\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  public parseLogs(logs: string[], callback: (log: Event) => void) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext(logScanner.next() as string);\n    let log = logScanner.next();\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n      if (event) {\n        callback(event);\n      }\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n      if (didPop) {\n        execution.pop();\n        // Skip the \"success\" log, which always follows the consumed log.\n        logScanner.next();\n      }\n      log = logScanner.next();\n    }\n  }\n\n  // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n  private handleLog(\n    execution: ExecutionContext,\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // Executing program is this program.\n    if (execution.program() === this.programId.toString()) {\n      return this.handleProgramLog(log);\n    }\n    // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs from *this* program.\n  private handleProgramLog(\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // This is a `msg!` log.\n    if (log.startsWith(\"Program log:\")) {\n      const logStr = log.slice(LOG_START_INDEX);\n      const logArr = Buffer.from(base64.toByteArray(logStr));\n      const disc = base64.fromByteArray(logArr.slice(0, 8));\n      // Only deserialize if the discriminator implies a proper event.\n      let event = null;\n      let eventName = this.discriminators.get(disc);\n      if (eventName !== undefined) {\n        event = {\n          name: eventName,\n          data: this.coder.events.decode(eventName, logArr.slice(8)),\n        };\n      }\n      return [event, null, false];\n    }\n    // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs when the current program being executing is *not* this.\n  private handleSystemLog(log: string): [string | null, boolean] {\n    // System component.\n    const logStart = log.split(\":\")[0];\n    // Recursive call.\n    if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n      return [this.programId.toString(), false];\n    }\n    // Cpi call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      // Did the program finish executing?\n      if (logStart.match(/^Program (.*) consumed .*$/g) !== null) {\n        return [null, true];\n      }\n      return [null, false];\n    }\n  }\n}\n\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n  stack: string[];\n\n  constructor(log: string) {\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    const program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n\n  program(): string {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram: string) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n}\n\nclass LogScanner {\n  constructor(public logs: string[]) {}\n\n  next(): string | null {\n    if (this.logs.length === 0) {\n      return null;\n    }\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n}\n","import * as bs58 from \"bs58\";\nimport { sha256 } from \"crypto-hash\";\nimport assert from \"assert\";\nimport { PublicKey, AccountInfo, Connection } from \"@solana/web3.js\";\nimport { idlAddress } from \"./idl\";\n\nexport const TOKEN_PROGRAM_ID = new PublicKey(\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nasync function getMultipleAccounts(\n  connection: Connection,\n  publicKeys: PublicKey[]\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (res.error) {\n    throw new Error(\n      \"failed to get info about accounts \" +\n        publicKeys.map((k) => k.toBase58()).join(\", \") +\n        \": \" +\n        res.error.message\n    );\n  }\n  assert(typeof res.result !== \"undefined\");\n  const accounts: Array<null | {\n    executable: any;\n    owner: PublicKey;\n    lamports: any;\n    data: Buffer;\n  }> = [];\n  for (const account of res.result.value) {\n    let value: {\n      executable: any;\n      owner: PublicKey;\n      lamports: any;\n      data: Buffer;\n    } | null = null;\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n    if (res.result.value) {\n      const { executable, owner, lamports, data } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\"),\n      };\n    }\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n    accounts.push(value);\n  }\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n    return {\n      publicKey: publicKeys[idx],\n      account,\n    };\n  });\n}\n\nexport function decodeUtf8(array: Uint8Array): string {\n  const decoder =\n    typeof TextDecoder === \"undefined\"\n      ? new (require(\"util\").TextDecoder)(\"utf-8\") // Node.\n      : new TextDecoder(\"utf-8\"); // Browser.\n  return decoder.decode(array);\n}\n\nconst utils = {\n  bs58,\n  sha256,\n  getMultipleAccounts,\n  idlAddress,\n};\n\nexport default utils;\n","import { inflate } from \"pako\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport Provider from \"../provider\";\nimport { Idl, idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory, {\n  RpcNamespace,\n  InstructionNamespace,\n  TransactionNamespace,\n  AccountNamespace,\n  StateNamespace,\n  SimulateNamespace,\n} from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { decodeUtf8 } from \"../utils\";\nimport { EventParser } from \"./event\";\n\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties (internally referred to as namespaces) that\n * map one-to-one to program instructions and accounts. These namespaces\n * generally can be used as follows:\n *\n * ```javascript\n * program.<namespace>.<program-specific-field>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://project-serum.github.io/anchor/ts/#examples).\n */\nexport class Program {\n  /**\n   * Async methods to send signed transactions invoking *non*-state methods\n   * on an Anchor program.\n   *\n   * ## rpc\n   *\n   * ```javascript\n   * program.rpc.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To send a transaction invoking the `increment` method above,\n   *\n   * ```javascript\n   * const txSignature = await program.rpc.increment({\n   *   accounts: {\n   *     counter,\n   *     authority,\n   *   },\n   * });\n   * ```\n   */\n  readonly rpc: RpcNamespace;\n\n  /**\n   * Async functions to fetch deserialized program accounts from a cluster.\n   *\n   * ## account\n   *\n   * ```javascript\n   * program.account.<account>(publicKey);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `publicKey` - The [[PublicKey]] of the account.\n   *\n   * ## Example\n   *\n   * To fetch a `Counter` object from the above example,\n   *\n   * ```javascript\n   * const counter = await program.account.counter(publicKey);\n   * ```\n   */\n  readonly account: AccountNamespace;\n\n  /**\n   * Functions to build [[TransactionInstruction]] objects for program methods.\n   *\n   * ## instruction\n   *\n   * ```javascript\n   * program.instruction.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To create an instruction for the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.instruction.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly instruction: InstructionNamespace;\n\n  /**\n   * Functions to build [[Transaction]] objects.\n   *\n   * ## transaction\n   *\n   * ```javascript\n   * program.transaction.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To create an instruction for the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.transaction.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly transaction: TransactionNamespace;\n\n  /**\n   * Async functions to simulate instructions against an Anchor program,\n   * returning a list of deserialized events *and* raw program logs.\n   *\n   * One can use this to read data calculated from a program on chain, by\n   * emitting an event in the program and reading the emitted event client side\n   * via the `simulate` namespace.\n   *\n   * ## simulate\n   *\n   * ```javascript\n   * program.simulate.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To simulate the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.simulate.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly simulate: SimulateNamespace;\n\n  /**\n   * Object with state account accessors and rpcs.\n   */\n  readonly state: StateNamespace;\n\n  /**\n   * Address of the program.\n   */\n  public get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  /**\n   * IDL defining the program's interface.\n   */\n  public get idl(): Idl {\n    return this._idl;\n  }\n  private _idl: Idl;\n\n  /**\n   * Coder for serializing requests.\n   */\n  public get coder(): Coder {\n    return this._coder;\n  }\n  private _coder: Coder;\n\n  /**\n   * Wallet and network provider.\n   */\n  public get provider(): Provider {\n    return this._provider;\n  }\n  private _provider: Provider;\n\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  public constructor(idl: Idl, programId: PublicKey, provider?: Provider) {\n    // Fields.\n    this._idl = idl;\n    this._programId = programId;\n    this._provider = provider ?? getProvider();\n    this._coder = new Coder(idl);\n\n    // Dynamic namespaces.\n    const [\n      rpc,\n      instruction,\n      transaction,\n      account,\n      state,\n      simulate,\n    ] = NamespaceFactory.build(idl, this._coder, programId, this._provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.state = state;\n    this.simulate = simulate;\n  }\n\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  public static async at(programId: PublicKey, provider?: Provider) {\n    const idl = await Program.fetchIdl(programId, provider);\n    return new Program(idl, programId, provider);\n  }\n\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  public static async fetchIdl(programId: PublicKey, provider?: Provider) {\n    provider = provider ?? getProvider();\n    const address = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(address);\n    // Chop off account discriminator.\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(decodeUtf8(inflatedIdl));\n  }\n\n  /**\n   * Invokes the given callback everytime the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n  public addEventListener(\n    eventName: string,\n    callback: (event: any, slot: number) => void\n  ): number {\n    const eventParser = new EventParser(\n      this._coder,\n      this._programId,\n      this._idl\n    );\n    return this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n      eventParser.parseLogs(logs.logs, (event) => {\n        if (event.name === eventName) {\n          callback(event.data, ctx.slot);\n        }\n      });\n    });\n  }\n\n  /**\n   * Unsubscribes from the given event listener.\n   */\n  public async removeEventListener(listener: number): Promise<void> {\n    return this._provider.connection.removeOnLogsListener(listener);\n  }\n}\n","import camelCase from \"camelcase\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport Coder from \"../../coder\";\nimport Provider from \"../../provider\";\nimport { Idl } from \"../../idl\";\nimport { parseIdlErrors } from \"../common\";\nimport StateFactory, { StateNamespace } from \"./state\";\nimport InstructionFactory, { InstructionNamespace } from \"./instruction\";\nimport TransactionFactory, { TransactionNamespace } from \"./transaction\";\nimport RpcFactory, { RpcNamespace } from \"./rpc\";\nimport AccountFactory, { AccountNamespace } from \"./account\";\nimport SimulateFactory, { SimulateNamespace } from \"./simulate\";\n\n// Re-exports.\nexport { StateNamespace } from \"./state\";\nexport { InstructionNamespace } from \"./instruction\";\nexport { TransactionNamespace, TxFn } from \"./transaction\";\nexport { RpcNamespace, RpcFn } from \"./rpc\";\nexport { AccountNamespace, AccountFn, ProgramAccount } from \"./account\";\nexport { SimulateNamespace } from \"./simulate\";\n\nexport default class NamespaceFactory {\n  /**\n   * Generates all namespaces for a given program.\n   */\n  public static build(\n    idl: Idl,\n    coder: Coder,\n    programId: PublicKey,\n    provider: Provider\n  ): [\n    RpcNamespace,\n    InstructionNamespace,\n    TransactionNamespace,\n    AccountNamespace,\n    StateNamespace,\n    SimulateNamespace\n  ] {\n    const idlErrors = parseIdlErrors(idl);\n\n    const rpc: RpcNamespace = {};\n    const instruction: InstructionNamespace = {};\n    const transaction: TransactionNamespace = {};\n    const simulate: SimulateNamespace = {};\n\n    const state = StateFactory.build(\n      idl,\n      coder,\n      programId,\n      idlErrors,\n      provider\n    );\n\n    idl.instructions.forEach((idlIx) => {\n      const ixItem = InstructionFactory.build(idlIx, coder, programId);\n      const txItem = TransactionFactory.build(idlIx, ixItem);\n      const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);\n      const simulateItem = SimulateFactory.build(\n        idlIx,\n        txItem,\n        idlErrors,\n        provider,\n        coder,\n        programId,\n        idl\n      );\n\n      const name = camelCase(idlIx.name);\n\n      instruction[name] = ixItem;\n      transaction[name] = txItem;\n      rpc[name] = rpcItem;\n      simulate[name] = simulateItem;\n    });\n\n    const account = idl.accounts\n      ? AccountFactory.build(idl, coder, programId, provider)\n      : {};\n\n    return [rpc, instruction, transaction, account, state, simulate];\n  }\n}\n","import { Transaction } from \"@solana/web3.js\";\nimport { IdlInstruction } from \"../../idl\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { IxFn } from \"./instruction\";\n\n/**\n * Dynamically generated transaction namespace.\n */\nexport interface TransactionNamespace {\n  [key: string]: TxFn;\n}\n\n/**\n * Tx is a function to create a `Transaction` generate from an IDL.\n */\nexport type TxFn = (...args: any[]) => Transaction;\n\nexport default class TransactionFactory {\n  // Builds the transaction namespace.\n  public static build(idlIx: IdlInstruction, ixFn: IxFn): TxFn {\n    const txFn = (...args: any[]): Transaction => {\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      const tx = new Transaction();\n      if (ctx.instructions !== undefined) {\n        tx.add(...ctx.instructions);\n      }\n      tx.add(ixFn(...args));\n      return tx;\n    };\n\n    return txFn;\n  }\n}\n","import { TransactionSignature } from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { IdlInstruction } from \"../../idl\";\nimport { translateError } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { TxFn } from \"./transaction\";\n\n/**\n * Dynamically generated rpc namespace.\n */\nexport interface RpcNamespace {\n  [key: string]: RpcFn;\n}\n\n/**\n * RpcFn is a single rpc method generated from an IDL.\n */\nexport type RpcFn = (...args: any[]) => Promise<TransactionSignature>;\n\nexport default class RpcFactory {\n  // Builds the rpc namespace.\n  public static build(\n    idlIx: IdlInstruction,\n    txFn: TxFn,\n    idlErrors: Map<number, string>,\n    provider: Provider\n  ): RpcFn {\n    const rpc = async (...args: any[]): Promise<TransactionSignature> => {\n      const tx = txFn(...args);\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      try {\n        const txSig = await provider.send(tx, ctx.signers, ctx.options);\n        return txSig;\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = translateError(idlErrors, err);\n        if (translatedErr === null) {\n          throw err;\n        }\n        throw translatedErr;\n      }\n    };\n\n    return rpc;\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { IdlInstruction } from \"../../idl\";\nimport { translateError } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { TxFn } from \"./transaction\";\nimport { EventParser } from \"../event\";\nimport Coder from \"../../coder\";\nimport { Idl } from \"../../idl\";\n\n/**\n * Dynamically generated simualte namespace.\n */\nexport interface SimulateNamespace {\n  [key: string]: SimulateFn;\n}\n\n/**\n * RpcFn is a single rpc method generated from an IDL.\n */\nexport type SimulateFn = (...args: any[]) => Promise<SimulateResponse>;\n\ntype SimulateResponse = {\n  events: Event[];\n  raw: string[];\n};\n\nexport default class SimulateFactory {\n  // Builds the rpc namespace.\n  public static build(\n    idlIx: IdlInstruction,\n    txFn: TxFn,\n    idlErrors: Map<number, string>,\n    provider: Provider,\n    coder: Coder,\n    programId: PublicKey,\n    idl: Idl\n  ): SimulateFn {\n    const simulate = async (...args: any[]): Promise<SimulateResponse> => {\n      const tx = txFn(...args);\n      const [_, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      let resp = undefined;\n      try {\n        resp = await provider.simulate(tx, ctx.signers, ctx.options);\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = translateError(idlErrors, err);\n        if (translatedErr === null) {\n          throw err;\n        }\n        throw translatedErr;\n      }\n      if (resp === undefined) {\n        throw new Error(\"Unable to simulate transaction\");\n      }\n      if (resp.value.err) {\n        throw new Error(`Simulate error: ${resp.value.err.toString()}`);\n      }\n      const logs = resp.value.logs;\n      if (!logs) {\n        throw new Error(\"Simulated logs not found\");\n      }\n\n      const events = [];\n      if (idl.events) {\n        let parser = new EventParser(coder, programId, idl);\n        parser.parseLogs(logs, (event) => {\n          events.push(event);\n        });\n      }\n      return { events, raw: logs };\n    };\n\n    return simulate;\n  }\n}\n","import camelCase from \"camelcase\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Program } from \"./program\";\n\nlet _populatedWorkspace = false;\n\n/**\n * The `workspace` namespace provides a convenience API to automatically\n * search for and deserialize [[Program]] objects defined by compiled IDLs\n * in an Anchor workspace.\n *\n * This API is for Node only.\n */\nconst workspace = new Proxy({} as any, {\n  get(workspaceCache: { [key: string]: Program }, programName: string) {\n    const find = require(\"find\");\n    const fs = require(\"fs\");\n    const process = require(\"process\");\n\n    if (typeof window !== \"undefined\") {\n      // Workspaces aren't available in the browser, yet.\n      return undefined;\n    }\n\n    if (!_populatedWorkspace) {\n      const path = require(\"path\");\n\n      let projectRoot = process.cwd();\n      while (!fs.existsSync(path.join(projectRoot, \"Anchor.toml\"))) {\n        const parentDir = path.dirname(projectRoot);\n        if (parentDir === projectRoot) {\n          projectRoot = undefined;\n        }\n        projectRoot = parentDir;\n      }\n\n      if (projectRoot === undefined) {\n        throw new Error(\"Could not find workspace root.\");\n      }\n\n      find\n        .fileSync(/target\\/idl\\/.*\\.json/, projectRoot)\n        .reduce((programs: any, path: string) => {\n          const idlStr = fs.readFileSync(path);\n          const idl = JSON.parse(idlStr);\n          const name = camelCase(idl.name, { pascalCase: true });\n          programs[name] = new Program(\n            idl,\n            new PublicKey(idl.metadata.address)\n          );\n          return programs;\n        }, workspaceCache);\n\n      _populatedWorkspace = true;\n    }\n\n    return workspaceCache[programName];\n  },\n});\n\nexport default workspace;\n","import BN from \"bn.js\";\nimport * as web3 from \"@solana/web3.js\";\nimport Provider, { NodeWallet as Wallet } from \"./provider\";\nimport Coder from \"./coder\";\nimport { Idl } from \"./idl\";\nimport workspace from \"./workspace\";\nimport utils from \"./utils\";\nimport { Program } from \"./program\";\nimport { ProgramAccount } from \"./program/namespace\";\nimport { Context, Accounts } from \"./program/context\";\n\nlet _provider: Provider | null = null;\n\nfunction setProvider(provider: Provider) {\n  _provider = provider;\n}\n\nfunction getProvider(): Provider {\n  if (_provider === null) {\n    return Provider.local();\n  }\n  return _provider;\n}\n\nexport {\n  workspace,\n  Program,\n  ProgramAccount,\n  Context,\n  Accounts,\n  Coder,\n  setProvider,\n  getProvider,\n  Provider,\n  BN,\n  web3,\n  Idl,\n  utils,\n  Wallet,\n};\n"],"names":["Provider","constructor","connection","wallet","opts","this","[object Object]","preflightCommitment","commitment","url","defaultOptions","Connection","NodeWallet","local","require","env","ANCHOR_PROVIDER_URL","undefined","Error","options","tx","signers","signerKps","filter","s","signerPubkeys","publicKey","concat","map","setSigners","recentBlockhash","getRecentBlockhash","blockhash","signTransaction","forEach","kp","partialSign","rawTx","serialize","sendAndConfirmRawTransaction","reqs","txs","r","signedTxs","signAllTransactions","sigs","k","length","push","async","transaction","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","args","_serialize","toString","encoding","res","_rpcRequest","error","message","result","simulateTransaction","payer","Account","Buffer","from","JSON","parse","readFileSync","homedir","t","IdlError","ProgramError","code","msg","params","super","Coder","idl","instruction","InstructionCoder","accounts","AccountsCoder","types","TypesCoder","events","EventCoder","state","StateCoder","sighash","nameSpace","ixName","ixLayout","parseIxLayout","encode","ix","_encode","encodeState","buffer","alloc","methodName","camelCase","len","get","data","slice","ixLayouts","methods","m","fieldLayouts","arg","IdlCoder","fieldLayout","name","borsh","struct","instructions","Map","accountLayouts","layouts","acc","typeDefLayout","accountName","account","accountData","discriminator","accountDiscriminator","decode","event","eventTypeDef","type","kind","fields","f","eventName","layout","disc","stateDiscriminator","accData","field","fieldName","bool","u8","u16","u32","u64","i64","u128","i128","vecU8","str","vec","option","defined","filtered","stringify","array","arrayLen","innerLayout","typeDef","variants","variant","rustEnum","replicate","sha256","digest","typeSize","ty","accountSize","arraySize","idlAccount","variantSizes","reduce","a","b","Math","max","snakeCase","idlAddress","programId","base","PublicKey","findProgramAddress","createWithSeed","IDL_ACCOUNT_LAYOUT","toInstruction","idlIx","idx","ixArg","validateAccounts","ixAccounts","translateError","idlErrors","err","components","split","errorCode","parseInt","errorMsg","parseErr","splitArgsAndCtx","inputLen","pop","InstructionNamespaceFactory","coder","ixArgs","ctx","keys","accountsArray","remainingAccounts","__private","logAccounts","console","log","TransactionInstruction","accs","nestedAccounts","flat","pubkey","isWritable","isMut","isSigner","programStateAddress","registrySigner","_nonce","subscriptions","LOG_START_INDEX","EventParser","discriminators","e","base64","fromByteArray","parseLogs","logs","callback","logScanner","LogScanner","execution","ExecutionContext","next","newProgram","didPop","handleLog","program","handleProgramLog","handleSystemLog","startsWith","logStr","logArr","toByteArray","logStart","includes","match","exec","stack","assert","ok","l","utils","bs58","getMultipleAccounts","publicKeys","toBase58","join","value","executable","owner","lamports","Program","provider","_idl","_programId","_provider","getProvider","_coder","rpc","simulate","errors","set","parseIdlErrors","addr","accountInfo","getAccountInfo","compare","programSigner","SystemProgram","SYSVAR_RENT_PUBKEY","stateInstructionKeys","ixFn","_","Transaction","add","send","translatedErr","sub","ee","EventEmitter","then","address","listener","onAccountChange","emit","removeAccountChangeListener","catch","build","ixItem","InstructionFactory","txItem","rpcItem","txFn","simulateItem","resp","raw","accountFns","accountsNamespace","sizeOverride","size","createAccount","fromPubkey","newAccountPubkey","space","getMinimumBalanceForRentExemption","delete","warn","bytes","filters","memcmp","offset","seeds","toBuffer","assoc","fetchIdl","inflatedIdl","inflate","TextDecoder","addEventListener","eventParser","onLogs","slot","removeOnLogsListener","_populatedWorkspace","workspace","Proxy","workspaceCache","programName","find","fs","process","window","path","projectRoot","cwd","existsSync","parentDir","dirname","fileSync","programs","idlStr","pascalCase","metadata","setProvider"],"mappings":"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"}